
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model DeviceLocation
 * 
 */
export type DeviceLocation = $Result.DefaultSelection<Prisma.$DeviceLocationPayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model DevicePolicy
 * 
 */
export type DevicePolicy = $Result.DefaultSelection<Prisma.$DevicePolicyPayload>
/**
 * Model Command
 * 
 */
export type Command = $Result.DefaultSelection<Prisma.$CommandPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model App
 * 
 */
export type App = $Result.DefaultSelection<Prisma.$AppPayload>
/**
 * Model DeviceApp
 * 
 */
export type DeviceApp = $Result.DefaultSelection<Prisma.$DeviceAppPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model DeviceGroup
 * 
 */
export type DeviceGroup = $Result.DefaultSelection<Prisma.$DeviceGroupPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  superadmin: 'superadmin',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const DeviceStatus: {
  active: 'active',
  locked: 'locked',
  wiped: 'wiped',
  kiosk: 'kiosk'
};

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus]


export const CommandType: {
  lock: 'lock',
  wipe: 'wipe',
  kiosk: 'kiosk',
  update_policy: 'update_policy',
  custom: 'custom'
};

export type CommandType = (typeof CommandType)[keyof typeof CommandType]


export const CommandStatus: {
  pending: 'pending',
  sent: 'sent',
  executed: 'executed',
  failed: 'failed'
};

export type CommandStatus = (typeof CommandStatus)[keyof typeof CommandStatus]


export const AppSource: {
  apk: 'apk',
  playstore: 'playstore'
};

export type AppSource = (typeof AppSource)[keyof typeof AppSource]


export const DeviceAppStatus: {
  pending: 'pending',
  installed: 'installed',
  failed: 'failed',
  removed: 'removed'
};

export type DeviceAppStatus = (typeof DeviceAppStatus)[keyof typeof DeviceAppStatus]


export const AlertType: {
  low_battery: 'low_battery',
  offline: 'offline',
  policy_violation: 'policy_violation',
  app_missing: 'app_missing',
  unauthorized_access: 'unauthorized_access'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AlertSeverity: {
  info: 'info',
  warning: 'warning',
  critical: 'critical'
};

export type AlertSeverity = (typeof AlertSeverity)[keyof typeof AlertSeverity]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type DeviceStatus = $Enums.DeviceStatus

export const DeviceStatus: typeof $Enums.DeviceStatus

export type CommandType = $Enums.CommandType

export const CommandType: typeof $Enums.CommandType

export type CommandStatus = $Enums.CommandStatus

export const CommandStatus: typeof $Enums.CommandStatus

export type AppSource = $Enums.AppSource

export const AppSource: typeof $Enums.AppSource

export type DeviceAppStatus = $Enums.DeviceAppStatus

export const DeviceAppStatus: typeof $Enums.DeviceAppStatus

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AlertSeverity = $Enums.AlertSeverity

export const AlertSeverity: typeof $Enums.AlertSeverity

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceLocation`: Exposes CRUD operations for the **DeviceLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceLocations
    * const deviceLocations = await prisma.deviceLocation.findMany()
    * ```
    */
  get deviceLocation(): Prisma.DeviceLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devicePolicy`: Exposes CRUD operations for the **DevicePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DevicePolicies
    * const devicePolicies = await prisma.devicePolicy.findMany()
    * ```
    */
  get devicePolicy(): Prisma.DevicePolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.app`: Exposes CRUD operations for the **App** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apps
    * const apps = await prisma.app.findMany()
    * ```
    */
  get app(): Prisma.AppDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceApp`: Exposes CRUD operations for the **DeviceApp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceApps
    * const deviceApps = await prisma.deviceApp.findMany()
    * ```
    */
  get deviceApp(): Prisma.DeviceAppDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceGroup`: Exposes CRUD operations for the **DeviceGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceGroups
    * const deviceGroups = await prisma.deviceGroup.findMany()
    * ```
    */
  get deviceGroup(): Prisma.DeviceGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    Device: 'Device',
    DeviceLocation: 'DeviceLocation',
    Policy: 'Policy',
    DevicePolicy: 'DevicePolicy',
    Command: 'Command',
    Log: 'Log',
    App: 'App',
    DeviceApp: 'DeviceApp',
    Group: 'Group',
    DeviceGroup: 'DeviceGroup',
    Alert: 'Alert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "device" | "deviceLocation" | "policy" | "devicePolicy" | "command" | "log" | "app" | "deviceApp" | "group" | "deviceGroup" | "alert"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceLocation: {
        payload: Prisma.$DeviceLocationPayload<ExtArgs>
        fields: Prisma.DeviceLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          findFirst: {
            args: Prisma.DeviceLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          findMany: {
            args: Prisma.DeviceLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>[]
          }
          create: {
            args: Prisma.DeviceLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          createMany: {
            args: Prisma.DeviceLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          update: {
            args: Prisma.DeviceLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          deleteMany: {
            args: Prisma.DeviceLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLocationPayload>
          }
          aggregate: {
            args: Prisma.DeviceLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceLocation>
          }
          groupBy: {
            args: Prisma.DeviceLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceLocationCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceLocationCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      DevicePolicy: {
        payload: Prisma.$DevicePolicyPayload<ExtArgs>
        fields: Prisma.DevicePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DevicePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DevicePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          findFirst: {
            args: Prisma.DevicePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DevicePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          findMany: {
            args: Prisma.DevicePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>[]
          }
          create: {
            args: Prisma.DevicePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          createMany: {
            args: Prisma.DevicePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DevicePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          update: {
            args: Prisma.DevicePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          deleteMany: {
            args: Prisma.DevicePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DevicePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DevicePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePolicyPayload>
          }
          aggregate: {
            args: Prisma.DevicePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevicePolicy>
          }
          groupBy: {
            args: Prisma.DevicePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevicePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DevicePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<DevicePolicyCountAggregateOutputType> | number
          }
        }
      }
      Command: {
        payload: Prisma.$CommandPayload<ExtArgs>
        fields: Prisma.CommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findFirst: {
            args: Prisma.CommandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findMany: {
            args: Prisma.CommandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          create: {
            args: Prisma.CommandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          createMany: {
            args: Prisma.CommandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          update: {
            args: Prisma.CommandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          deleteMany: {
            args: Prisma.CommandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          aggregate: {
            args: Prisma.CommandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommand>
          }
          groupBy: {
            args: Prisma.CommandGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandCountArgs<ExtArgs>
            result: $Utils.Optional<CommandCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      App: {
        payload: Prisma.$AppPayload<ExtArgs>
        fields: Prisma.AppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findFirst: {
            args: Prisma.AppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findMany: {
            args: Prisma.AppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          create: {
            args: Prisma.AppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          createMany: {
            args: Prisma.AppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          update: {
            args: Prisma.AppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          deleteMany: {
            args: Prisma.AppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          aggregate: {
            args: Prisma.AppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp>
          }
          groupBy: {
            args: Prisma.AppGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppCountArgs<ExtArgs>
            result: $Utils.Optional<AppCountAggregateOutputType> | number
          }
        }
      }
      DeviceApp: {
        payload: Prisma.$DeviceAppPayload<ExtArgs>
        fields: Prisma.DeviceAppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceAppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceAppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          findFirst: {
            args: Prisma.DeviceAppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceAppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          findMany: {
            args: Prisma.DeviceAppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>[]
          }
          create: {
            args: Prisma.DeviceAppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          createMany: {
            args: Prisma.DeviceAppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceAppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          update: {
            args: Prisma.DeviceAppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          deleteMany: {
            args: Prisma.DeviceAppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceAppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceAppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAppPayload>
          }
          aggregate: {
            args: Prisma.DeviceAppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceApp>
          }
          groupBy: {
            args: Prisma.DeviceAppGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceAppGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceAppCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceAppCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      DeviceGroup: {
        payload: Prisma.$DeviceGroupPayload<ExtArgs>
        fields: Prisma.DeviceGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          findFirst: {
            args: Prisma.DeviceGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          findMany: {
            args: Prisma.DeviceGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>[]
          }
          create: {
            args: Prisma.DeviceGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          createMany: {
            args: Prisma.DeviceGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          update: {
            args: Prisma.DeviceGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          deleteMany: {
            args: Prisma.DeviceGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupPayload>
          }
          aggregate: {
            args: Prisma.DeviceGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceGroup>
          }
          groupBy: {
            args: Prisma.DeviceGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceGroupCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    device?: DeviceOmit
    deviceLocation?: DeviceLocationOmit
    policy?: PolicyOmit
    devicePolicy?: DevicePolicyOmit
    command?: CommandOmit
    log?: LogOmit
    app?: AppOmit
    deviceApp?: DeviceAppOmit
    group?: GroupOmit
    deviceGroup?: DeviceGroupOmit
    alert?: AlertOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    commands: number
    logs: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | AdminCountOutputTypeCountCommandsArgs
    logs?: boolean | AdminCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    locations: number
    devicePolicies: number
    commands: number
    deviceApps: number
    deviceGroups: number
    alerts: number
    logs: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | DeviceCountOutputTypeCountLocationsArgs
    devicePolicies?: boolean | DeviceCountOutputTypeCountDevicePoliciesArgs
    commands?: boolean | DeviceCountOutputTypeCountCommandsArgs
    deviceApps?: boolean | DeviceCountOutputTypeCountDeviceAppsArgs
    deviceGroups?: boolean | DeviceCountOutputTypeCountDeviceGroupsArgs
    alerts?: boolean | DeviceCountOutputTypeCountAlertsArgs
    logs?: boolean | DeviceCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLocationWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDevicePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevicePolicyWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDeviceAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceAppWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDeviceGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Count Type PolicyCountOutputType
   */

  export type PolicyCountOutputType = {
    devicePolicies: number
  }

  export type PolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devicePolicies?: boolean | PolicyCountOutputTypeCountDevicePoliciesArgs
  }

  // Custom InputTypes
  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyCountOutputType
     */
    select?: PolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountDevicePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevicePolicyWhereInput
  }


  /**
   * Count Type AppCountOutputType
   */

  export type AppCountOutputType = {
    deviceApps: number
  }

  export type AppCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceApps?: boolean | AppCountOutputTypeCountDeviceAppsArgs
  }

  // Custom InputTypes
  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppCountOutputType
     */
    select?: AppCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountDeviceAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceAppWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    deviceGroups: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceGroups?: boolean | GroupCountOutputTypeCountDeviceGroupsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountDeviceGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.Role | null
    created_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.Role | null
    created_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password_hash: number
    role: number
    created_at: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string
    email: string
    password_hash: string
    role: $Enums.Role
    created_at: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
    commands?: boolean | Admin$commandsArgs<ExtArgs>
    logs?: boolean | Admin$logsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password_hash" | "role" | "created_at", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commands?: boolean | Admin$commandsArgs<ExtArgs>
    logs?: boolean | Admin$logsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      commands: Prisma.$CommandPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password_hash: string
      role: $Enums.Role
      created_at: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commands<T extends Admin$commandsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Admin$logsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password_hash: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.commands
   */
  export type Admin$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Admin.logs
   */
  export type Admin$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    battery_level: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    battery_level: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    device_id: string | null
    serial_number: string | null
    model: string | null
    brand: string | null
    os_version: string | null
    enrolled_at: Date | null
    last_seen: Date | null
    battery_level: number | null
    network_status: string | null
    status: $Enums.DeviceStatus | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    device_id: string | null
    serial_number: string | null
    model: string | null
    brand: string | null
    os_version: string | null
    enrolled_at: Date | null
    last_seen: Date | null
    battery_level: number | null
    network_status: string | null
    status: $Enums.DeviceStatus | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    device_id: number
    serial_number: number
    model: number
    brand: number
    os_version: number
    enrolled_at: number
    last_seen: number
    battery_level: number
    network_status: number
    status: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    battery_level?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    battery_level?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    device_id?: true
    serial_number?: true
    model?: true
    brand?: true
    os_version?: true
    enrolled_at?: true
    last_seen?: true
    battery_level?: true
    network_status?: true
    status?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    device_id?: true
    serial_number?: true
    model?: true
    brand?: true
    os_version?: true
    enrolled_at?: true
    last_seen?: true
    battery_level?: true
    network_status?: true
    status?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    device_id?: true
    serial_number?: true
    model?: true
    brand?: true
    os_version?: true
    enrolled_at?: true
    last_seen?: true
    battery_level?: true
    network_status?: true
    status?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    device_id: string
    serial_number: string | null
    model: string | null
    brand: string | null
    os_version: string | null
    enrolled_at: Date
    last_seen: Date | null
    battery_level: number | null
    network_status: string | null
    status: $Enums.DeviceStatus
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    serial_number?: boolean
    model?: boolean
    brand?: boolean
    os_version?: boolean
    enrolled_at?: boolean
    last_seen?: boolean
    battery_level?: boolean
    network_status?: boolean
    status?: boolean
    locations?: boolean | Device$locationsArgs<ExtArgs>
    devicePolicies?: boolean | Device$devicePoliciesArgs<ExtArgs>
    commands?: boolean | Device$commandsArgs<ExtArgs>
    deviceApps?: boolean | Device$deviceAppsArgs<ExtArgs>
    deviceGroups?: boolean | Device$deviceGroupsArgs<ExtArgs>
    alerts?: boolean | Device$alertsArgs<ExtArgs>
    logs?: boolean | Device$logsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>



  export type DeviceSelectScalar = {
    id?: boolean
    device_id?: boolean
    serial_number?: boolean
    model?: boolean
    brand?: boolean
    os_version?: boolean
    enrolled_at?: boolean
    last_seen?: boolean
    battery_level?: boolean
    network_status?: boolean
    status?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "serial_number" | "model" | "brand" | "os_version" | "enrolled_at" | "last_seen" | "battery_level" | "network_status" | "status", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Device$locationsArgs<ExtArgs>
    devicePolicies?: boolean | Device$devicePoliciesArgs<ExtArgs>
    commands?: boolean | Device$commandsArgs<ExtArgs>
    deviceApps?: boolean | Device$deviceAppsArgs<ExtArgs>
    deviceGroups?: boolean | Device$deviceGroupsArgs<ExtArgs>
    alerts?: boolean | Device$alertsArgs<ExtArgs>
    logs?: boolean | Device$logsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      locations: Prisma.$DeviceLocationPayload<ExtArgs>[]
      devicePolicies: Prisma.$DevicePolicyPayload<ExtArgs>[]
      commands: Prisma.$CommandPayload<ExtArgs>[]
      deviceApps: Prisma.$DeviceAppPayload<ExtArgs>[]
      deviceGroups: Prisma.$DeviceGroupPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: string
      serial_number: string | null
      model: string | null
      brand: string | null
      os_version: string | null
      enrolled_at: Date
      last_seen: Date | null
      battery_level: number | null
      network_status: string | null
      status: $Enums.DeviceStatus
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends Device$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Device$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devicePolicies<T extends Device$devicePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, Device$devicePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commands<T extends Device$commandsArgs<ExtArgs> = {}>(args?: Subset<T, Device$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceApps<T extends Device$deviceAppsArgs<ExtArgs> = {}>(args?: Subset<T, Device$deviceAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceGroups<T extends Device$deviceGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Device$deviceGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Device$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Device$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Device$logsArgs<ExtArgs> = {}>(args?: Subset<T, Device$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'Int'>
    readonly device_id: FieldRef<"Device", 'String'>
    readonly serial_number: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly brand: FieldRef<"Device", 'String'>
    readonly os_version: FieldRef<"Device", 'String'>
    readonly enrolled_at: FieldRef<"Device", 'DateTime'>
    readonly last_seen: FieldRef<"Device", 'DateTime'>
    readonly battery_level: FieldRef<"Device", 'Int'>
    readonly network_status: FieldRef<"Device", 'String'>
    readonly status: FieldRef<"Device", 'DeviceStatus'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device.locations
   */
  export type Device$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    where?: DeviceLocationWhereInput
    orderBy?: DeviceLocationOrderByWithRelationInput | DeviceLocationOrderByWithRelationInput[]
    cursor?: DeviceLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceLocationScalarFieldEnum | DeviceLocationScalarFieldEnum[]
  }

  /**
   * Device.devicePolicies
   */
  export type Device$devicePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    where?: DevicePolicyWhereInput
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    cursor?: DevicePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DevicePolicyScalarFieldEnum | DevicePolicyScalarFieldEnum[]
  }

  /**
   * Device.commands
   */
  export type Device$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Device.deviceApps
   */
  export type Device$deviceAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    where?: DeviceAppWhereInput
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    cursor?: DeviceAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceAppScalarFieldEnum | DeviceAppScalarFieldEnum[]
  }

  /**
   * Device.deviceGroups
   */
  export type Device$deviceGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    where?: DeviceGroupWhereInput
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    cursor?: DeviceGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupScalarFieldEnum | DeviceGroupScalarFieldEnum[]
  }

  /**
   * Device.alerts
   */
  export type Device$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Device.logs
   */
  export type Device$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceLocation
   */

  export type AggregateDeviceLocation = {
    _count: DeviceLocationCountAggregateOutputType | null
    _avg: DeviceLocationAvgAggregateOutputType | null
    _sum: DeviceLocationSumAggregateOutputType | null
    _min: DeviceLocationMinAggregateOutputType | null
    _max: DeviceLocationMaxAggregateOutputType | null
  }

  export type DeviceLocationAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type DeviceLocationSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type DeviceLocationMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    recorded_at: Date | null
  }

  export type DeviceLocationMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    recorded_at: Date | null
  }

  export type DeviceLocationCountAggregateOutputType = {
    id: number
    device_id: number
    latitude: number
    longitude: number
    recorded_at: number
    _all: number
  }


  export type DeviceLocationAvgAggregateInputType = {
    id?: true
    device_id?: true
    latitude?: true
    longitude?: true
  }

  export type DeviceLocationSumAggregateInputType = {
    id?: true
    device_id?: true
    latitude?: true
    longitude?: true
  }

  export type DeviceLocationMinAggregateInputType = {
    id?: true
    device_id?: true
    latitude?: true
    longitude?: true
    recorded_at?: true
  }

  export type DeviceLocationMaxAggregateInputType = {
    id?: true
    device_id?: true
    latitude?: true
    longitude?: true
    recorded_at?: true
  }

  export type DeviceLocationCountAggregateInputType = {
    id?: true
    device_id?: true
    latitude?: true
    longitude?: true
    recorded_at?: true
    _all?: true
  }

  export type DeviceLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLocation to aggregate.
     */
    where?: DeviceLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLocations to fetch.
     */
    orderBy?: DeviceLocationOrderByWithRelationInput | DeviceLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceLocations
    **/
    _count?: true | DeviceLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceLocationMaxAggregateInputType
  }

  export type GetDeviceLocationAggregateType<T extends DeviceLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceLocation[P]>
      : GetScalarType<T[P], AggregateDeviceLocation[P]>
  }




  export type DeviceLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLocationWhereInput
    orderBy?: DeviceLocationOrderByWithAggregationInput | DeviceLocationOrderByWithAggregationInput[]
    by: DeviceLocationScalarFieldEnum[] | DeviceLocationScalarFieldEnum
    having?: DeviceLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceLocationCountAggregateInputType | true
    _avg?: DeviceLocationAvgAggregateInputType
    _sum?: DeviceLocationSumAggregateInputType
    _min?: DeviceLocationMinAggregateInputType
    _max?: DeviceLocationMaxAggregateInputType
  }

  export type DeviceLocationGroupByOutputType = {
    id: number
    device_id: number
    latitude: Decimal | null
    longitude: Decimal | null
    recorded_at: Date
    _count: DeviceLocationCountAggregateOutputType | null
    _avg: DeviceLocationAvgAggregateOutputType | null
    _sum: DeviceLocationSumAggregateOutputType | null
    _min: DeviceLocationMinAggregateOutputType | null
    _max: DeviceLocationMaxAggregateOutputType | null
  }

  type GetDeviceLocationGroupByPayload<T extends DeviceLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceLocationGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceLocationGroupByOutputType[P]>
        }
      >
    >


  export type DeviceLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    latitude?: boolean
    longitude?: boolean
    recorded_at?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceLocation"]>



  export type DeviceLocationSelectScalar = {
    id?: boolean
    device_id?: boolean
    latitude?: boolean
    longitude?: boolean
    recorded_at?: boolean
  }

  export type DeviceLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "latitude" | "longitude" | "recorded_at", ExtArgs["result"]["deviceLocation"]>
  export type DeviceLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceLocation"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      recorded_at: Date
    }, ExtArgs["result"]["deviceLocation"]>
    composites: {}
  }

  type DeviceLocationGetPayload<S extends boolean | null | undefined | DeviceLocationDefaultArgs> = $Result.GetResult<Prisma.$DeviceLocationPayload, S>

  type DeviceLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceLocationCountAggregateInputType | true
    }

  export interface DeviceLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceLocation'], meta: { name: 'DeviceLocation' } }
    /**
     * Find zero or one DeviceLocation that matches the filter.
     * @param {DeviceLocationFindUniqueArgs} args - Arguments to find a DeviceLocation
     * @example
     * // Get one DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceLocationFindUniqueArgs>(args: SelectSubset<T, DeviceLocationFindUniqueArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceLocationFindUniqueOrThrowArgs} args - Arguments to find a DeviceLocation
     * @example
     * // Get one DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationFindFirstArgs} args - Arguments to find a DeviceLocation
     * @example
     * // Get one DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceLocationFindFirstArgs>(args?: SelectSubset<T, DeviceLocationFindFirstArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationFindFirstOrThrowArgs} args - Arguments to find a DeviceLocation
     * @example
     * // Get one DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceLocations
     * const deviceLocations = await prisma.deviceLocation.findMany()
     * 
     * // Get first 10 DeviceLocations
     * const deviceLocations = await prisma.deviceLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceLocationWithIdOnly = await prisma.deviceLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceLocationFindManyArgs>(args?: SelectSubset<T, DeviceLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceLocation.
     * @param {DeviceLocationCreateArgs} args - Arguments to create a DeviceLocation.
     * @example
     * // Create one DeviceLocation
     * const DeviceLocation = await prisma.deviceLocation.create({
     *   data: {
     *     // ... data to create a DeviceLocation
     *   }
     * })
     * 
     */
    create<T extends DeviceLocationCreateArgs>(args: SelectSubset<T, DeviceLocationCreateArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceLocations.
     * @param {DeviceLocationCreateManyArgs} args - Arguments to create many DeviceLocations.
     * @example
     * // Create many DeviceLocations
     * const deviceLocation = await prisma.deviceLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceLocationCreateManyArgs>(args?: SelectSubset<T, DeviceLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceLocation.
     * @param {DeviceLocationDeleteArgs} args - Arguments to delete one DeviceLocation.
     * @example
     * // Delete one DeviceLocation
     * const DeviceLocation = await prisma.deviceLocation.delete({
     *   where: {
     *     // ... filter to delete one DeviceLocation
     *   }
     * })
     * 
     */
    delete<T extends DeviceLocationDeleteArgs>(args: SelectSubset<T, DeviceLocationDeleteArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceLocation.
     * @param {DeviceLocationUpdateArgs} args - Arguments to update one DeviceLocation.
     * @example
     * // Update one DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceLocationUpdateArgs>(args: SelectSubset<T, DeviceLocationUpdateArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceLocations.
     * @param {DeviceLocationDeleteManyArgs} args - Arguments to filter DeviceLocations to delete.
     * @example
     * // Delete a few DeviceLocations
     * const { count } = await prisma.deviceLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceLocationDeleteManyArgs>(args?: SelectSubset<T, DeviceLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceLocations
     * const deviceLocation = await prisma.deviceLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceLocationUpdateManyArgs>(args: SelectSubset<T, DeviceLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceLocation.
     * @param {DeviceLocationUpsertArgs} args - Arguments to update or create a DeviceLocation.
     * @example
     * // Update or create a DeviceLocation
     * const deviceLocation = await prisma.deviceLocation.upsert({
     *   create: {
     *     // ... data to create a DeviceLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceLocation we want to update
     *   }
     * })
     */
    upsert<T extends DeviceLocationUpsertArgs>(args: SelectSubset<T, DeviceLocationUpsertArgs<ExtArgs>>): Prisma__DeviceLocationClient<$Result.GetResult<Prisma.$DeviceLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationCountArgs} args - Arguments to filter DeviceLocations to count.
     * @example
     * // Count the number of DeviceLocations
     * const count = await prisma.deviceLocation.count({
     *   where: {
     *     // ... the filter for the DeviceLocations we want to count
     *   }
     * })
    **/
    count<T extends DeviceLocationCountArgs>(
      args?: Subset<T, DeviceLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceLocationAggregateArgs>(args: Subset<T, DeviceLocationAggregateArgs>): Prisma.PrismaPromise<GetDeviceLocationAggregateType<T>>

    /**
     * Group by DeviceLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceLocationGroupByArgs['orderBy'] }
        : { orderBy?: DeviceLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceLocation model
   */
  readonly fields: DeviceLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceLocation model
   */
  interface DeviceLocationFieldRefs {
    readonly id: FieldRef<"DeviceLocation", 'Int'>
    readonly device_id: FieldRef<"DeviceLocation", 'Int'>
    readonly latitude: FieldRef<"DeviceLocation", 'Decimal'>
    readonly longitude: FieldRef<"DeviceLocation", 'Decimal'>
    readonly recorded_at: FieldRef<"DeviceLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceLocation findUnique
   */
  export type DeviceLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLocation to fetch.
     */
    where: DeviceLocationWhereUniqueInput
  }

  /**
   * DeviceLocation findUniqueOrThrow
   */
  export type DeviceLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLocation to fetch.
     */
    where: DeviceLocationWhereUniqueInput
  }

  /**
   * DeviceLocation findFirst
   */
  export type DeviceLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLocation to fetch.
     */
    where?: DeviceLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLocations to fetch.
     */
    orderBy?: DeviceLocationOrderByWithRelationInput | DeviceLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLocations.
     */
    cursor?: DeviceLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLocations.
     */
    distinct?: DeviceLocationScalarFieldEnum | DeviceLocationScalarFieldEnum[]
  }

  /**
   * DeviceLocation findFirstOrThrow
   */
  export type DeviceLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLocation to fetch.
     */
    where?: DeviceLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLocations to fetch.
     */
    orderBy?: DeviceLocationOrderByWithRelationInput | DeviceLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLocations.
     */
    cursor?: DeviceLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLocations.
     */
    distinct?: DeviceLocationScalarFieldEnum | DeviceLocationScalarFieldEnum[]
  }

  /**
   * DeviceLocation findMany
   */
  export type DeviceLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLocations to fetch.
     */
    where?: DeviceLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLocations to fetch.
     */
    orderBy?: DeviceLocationOrderByWithRelationInput | DeviceLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceLocations.
     */
    cursor?: DeviceLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLocations.
     */
    skip?: number
    distinct?: DeviceLocationScalarFieldEnum | DeviceLocationScalarFieldEnum[]
  }

  /**
   * DeviceLocation create
   */
  export type DeviceLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceLocation.
     */
    data: XOR<DeviceLocationCreateInput, DeviceLocationUncheckedCreateInput>
  }

  /**
   * DeviceLocation createMany
   */
  export type DeviceLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceLocations.
     */
    data: DeviceLocationCreateManyInput | DeviceLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLocation update
   */
  export type DeviceLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceLocation.
     */
    data: XOR<DeviceLocationUpdateInput, DeviceLocationUncheckedUpdateInput>
    /**
     * Choose, which DeviceLocation to update.
     */
    where: DeviceLocationWhereUniqueInput
  }

  /**
   * DeviceLocation updateMany
   */
  export type DeviceLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceLocations.
     */
    data: XOR<DeviceLocationUpdateManyMutationInput, DeviceLocationUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLocations to update
     */
    where?: DeviceLocationWhereInput
    /**
     * Limit how many DeviceLocations to update.
     */
    limit?: number
  }

  /**
   * DeviceLocation upsert
   */
  export type DeviceLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceLocation to update in case it exists.
     */
    where: DeviceLocationWhereUniqueInput
    /**
     * In case the DeviceLocation found by the `where` argument doesn't exist, create a new DeviceLocation with this data.
     */
    create: XOR<DeviceLocationCreateInput, DeviceLocationUncheckedCreateInput>
    /**
     * In case the DeviceLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceLocationUpdateInput, DeviceLocationUncheckedUpdateInput>
  }

  /**
   * DeviceLocation delete
   */
  export type DeviceLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
    /**
     * Filter which DeviceLocation to delete.
     */
    where: DeviceLocationWhereUniqueInput
  }

  /**
   * DeviceLocation deleteMany
   */
  export type DeviceLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLocations to delete
     */
    where?: DeviceLocationWhereInput
    /**
     * Limit how many DeviceLocations to delete.
     */
    limit?: number
  }

  /**
   * DeviceLocation without action
   */
  export type DeviceLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLocation
     */
    select?: DeviceLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLocation
     */
    omit?: DeviceLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLocationInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    id: number | null
  }

  export type PolicySumAggregateOutputType = {
    id: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    allow_camera: boolean | null
    allow_wifi: boolean | null
    allow_bluetooth: boolean | null
    require_password: boolean | null
    kiosk_mode: boolean | null
    created_at: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    allow_camera: boolean | null
    allow_wifi: boolean | null
    allow_bluetooth: boolean | null
    require_password: boolean | null
    kiosk_mode: boolean | null
    created_at: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    allow_camera: number
    allow_wifi: number
    allow_bluetooth: number
    require_password: number
    kiosk_mode: number
    created_at: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    id?: true
  }

  export type PolicySumAggregateInputType = {
    id?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    allow_camera?: true
    allow_wifi?: true
    allow_bluetooth?: true
    require_password?: true
    kiosk_mode?: true
    created_at?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    allow_camera?: true
    allow_wifi?: true
    allow_bluetooth?: true
    require_password?: true
    kiosk_mode?: true
    created_at?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    allow_camera?: true
    allow_wifi?: true
    allow_bluetooth?: true
    require_password?: true
    kiosk_mode?: true
    created_at?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: number
    name: string
    description: string | null
    allow_camera: boolean
    allow_wifi: boolean
    allow_bluetooth: boolean
    require_password: boolean
    kiosk_mode: boolean
    created_at: Date
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: boolean
    devicePolicies?: boolean | Policy$devicePoliciesArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>



  export type PolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: boolean
  }

  export type PolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "allow_camera" | "allow_wifi" | "allow_bluetooth" | "require_password" | "kiosk_mode" | "created_at", ExtArgs["result"]["policy"]>
  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devicePolicies?: boolean | Policy$devicePoliciesArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      devicePolicies: Prisma.$DevicePolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      allow_camera: boolean
      allow_wifi: boolean
      allow_bluetooth: boolean
      require_password: boolean
      kiosk_mode: boolean
      created_at: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devicePolicies<T extends Policy$devicePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, Policy$devicePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'Int'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly allow_camera: FieldRef<"Policy", 'Boolean'>
    readonly allow_wifi: FieldRef<"Policy", 'Boolean'>
    readonly allow_bluetooth: FieldRef<"Policy", 'Boolean'>
    readonly require_password: FieldRef<"Policy", 'Boolean'>
    readonly kiosk_mode: FieldRef<"Policy", 'Boolean'>
    readonly created_at: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to delete.
     */
    limit?: number
  }

  /**
   * Policy.devicePolicies
   */
  export type Policy$devicePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    where?: DevicePolicyWhereInput
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    cursor?: DevicePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DevicePolicyScalarFieldEnum | DevicePolicyScalarFieldEnum[]
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model DevicePolicy
   */

  export type AggregateDevicePolicy = {
    _count: DevicePolicyCountAggregateOutputType | null
    _avg: DevicePolicyAvgAggregateOutputType | null
    _sum: DevicePolicySumAggregateOutputType | null
    _min: DevicePolicyMinAggregateOutputType | null
    _max: DevicePolicyMaxAggregateOutputType | null
  }

  export type DevicePolicyAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    policy_id: number | null
  }

  export type DevicePolicySumAggregateOutputType = {
    id: number | null
    device_id: number | null
    policy_id: number | null
  }

  export type DevicePolicyMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    policy_id: number | null
    applied_at: Date | null
  }

  export type DevicePolicyMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    policy_id: number | null
    applied_at: Date | null
  }

  export type DevicePolicyCountAggregateOutputType = {
    id: number
    device_id: number
    policy_id: number
    applied_at: number
    _all: number
  }


  export type DevicePolicyAvgAggregateInputType = {
    id?: true
    device_id?: true
    policy_id?: true
  }

  export type DevicePolicySumAggregateInputType = {
    id?: true
    device_id?: true
    policy_id?: true
  }

  export type DevicePolicyMinAggregateInputType = {
    id?: true
    device_id?: true
    policy_id?: true
    applied_at?: true
  }

  export type DevicePolicyMaxAggregateInputType = {
    id?: true
    device_id?: true
    policy_id?: true
    applied_at?: true
  }

  export type DevicePolicyCountAggregateInputType = {
    id?: true
    device_id?: true
    policy_id?: true
    applied_at?: true
    _all?: true
  }

  export type DevicePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevicePolicy to aggregate.
     */
    where?: DevicePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevicePolicies to fetch.
     */
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DevicePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevicePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevicePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DevicePolicies
    **/
    _count?: true | DevicePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevicePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevicePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevicePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevicePolicyMaxAggregateInputType
  }

  export type GetDevicePolicyAggregateType<T extends DevicePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateDevicePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevicePolicy[P]>
      : GetScalarType<T[P], AggregateDevicePolicy[P]>
  }




  export type DevicePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevicePolicyWhereInput
    orderBy?: DevicePolicyOrderByWithAggregationInput | DevicePolicyOrderByWithAggregationInput[]
    by: DevicePolicyScalarFieldEnum[] | DevicePolicyScalarFieldEnum
    having?: DevicePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevicePolicyCountAggregateInputType | true
    _avg?: DevicePolicyAvgAggregateInputType
    _sum?: DevicePolicySumAggregateInputType
    _min?: DevicePolicyMinAggregateInputType
    _max?: DevicePolicyMaxAggregateInputType
  }

  export type DevicePolicyGroupByOutputType = {
    id: number
    device_id: number
    policy_id: number
    applied_at: Date
    _count: DevicePolicyCountAggregateOutputType | null
    _avg: DevicePolicyAvgAggregateOutputType | null
    _sum: DevicePolicySumAggregateOutputType | null
    _min: DevicePolicyMinAggregateOutputType | null
    _max: DevicePolicyMaxAggregateOutputType | null
  }

  type GetDevicePolicyGroupByPayload<T extends DevicePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevicePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevicePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevicePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], DevicePolicyGroupByOutputType[P]>
        }
      >
    >


  export type DevicePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    policy_id?: boolean
    applied_at?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devicePolicy"]>



  export type DevicePolicySelectScalar = {
    id?: boolean
    device_id?: boolean
    policy_id?: boolean
    applied_at?: boolean
  }

  export type DevicePolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "policy_id" | "applied_at", ExtArgs["result"]["devicePolicy"]>
  export type DevicePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }

  export type $DevicePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DevicePolicy"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      policy: Prisma.$PolicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      policy_id: number
      applied_at: Date
    }, ExtArgs["result"]["devicePolicy"]>
    composites: {}
  }

  type DevicePolicyGetPayload<S extends boolean | null | undefined | DevicePolicyDefaultArgs> = $Result.GetResult<Prisma.$DevicePolicyPayload, S>

  type DevicePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DevicePolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevicePolicyCountAggregateInputType | true
    }

  export interface DevicePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DevicePolicy'], meta: { name: 'DevicePolicy' } }
    /**
     * Find zero or one DevicePolicy that matches the filter.
     * @param {DevicePolicyFindUniqueArgs} args - Arguments to find a DevicePolicy
     * @example
     * // Get one DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DevicePolicyFindUniqueArgs>(args: SelectSubset<T, DevicePolicyFindUniqueArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DevicePolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DevicePolicyFindUniqueOrThrowArgs} args - Arguments to find a DevicePolicy
     * @example
     * // Get one DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DevicePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, DevicePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevicePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyFindFirstArgs} args - Arguments to find a DevicePolicy
     * @example
     * // Get one DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DevicePolicyFindFirstArgs>(args?: SelectSubset<T, DevicePolicyFindFirstArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevicePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyFindFirstOrThrowArgs} args - Arguments to find a DevicePolicy
     * @example
     * // Get one DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DevicePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, DevicePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DevicePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DevicePolicies
     * const devicePolicies = await prisma.devicePolicy.findMany()
     * 
     * // Get first 10 DevicePolicies
     * const devicePolicies = await prisma.devicePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const devicePolicyWithIdOnly = await prisma.devicePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DevicePolicyFindManyArgs>(args?: SelectSubset<T, DevicePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DevicePolicy.
     * @param {DevicePolicyCreateArgs} args - Arguments to create a DevicePolicy.
     * @example
     * // Create one DevicePolicy
     * const DevicePolicy = await prisma.devicePolicy.create({
     *   data: {
     *     // ... data to create a DevicePolicy
     *   }
     * })
     * 
     */
    create<T extends DevicePolicyCreateArgs>(args: SelectSubset<T, DevicePolicyCreateArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DevicePolicies.
     * @param {DevicePolicyCreateManyArgs} args - Arguments to create many DevicePolicies.
     * @example
     * // Create many DevicePolicies
     * const devicePolicy = await prisma.devicePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DevicePolicyCreateManyArgs>(args?: SelectSubset<T, DevicePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DevicePolicy.
     * @param {DevicePolicyDeleteArgs} args - Arguments to delete one DevicePolicy.
     * @example
     * // Delete one DevicePolicy
     * const DevicePolicy = await prisma.devicePolicy.delete({
     *   where: {
     *     // ... filter to delete one DevicePolicy
     *   }
     * })
     * 
     */
    delete<T extends DevicePolicyDeleteArgs>(args: SelectSubset<T, DevicePolicyDeleteArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DevicePolicy.
     * @param {DevicePolicyUpdateArgs} args - Arguments to update one DevicePolicy.
     * @example
     * // Update one DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DevicePolicyUpdateArgs>(args: SelectSubset<T, DevicePolicyUpdateArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DevicePolicies.
     * @param {DevicePolicyDeleteManyArgs} args - Arguments to filter DevicePolicies to delete.
     * @example
     * // Delete a few DevicePolicies
     * const { count } = await prisma.devicePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DevicePolicyDeleteManyArgs>(args?: SelectSubset<T, DevicePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevicePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DevicePolicies
     * const devicePolicy = await prisma.devicePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DevicePolicyUpdateManyArgs>(args: SelectSubset<T, DevicePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DevicePolicy.
     * @param {DevicePolicyUpsertArgs} args - Arguments to update or create a DevicePolicy.
     * @example
     * // Update or create a DevicePolicy
     * const devicePolicy = await prisma.devicePolicy.upsert({
     *   create: {
     *     // ... data to create a DevicePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DevicePolicy we want to update
     *   }
     * })
     */
    upsert<T extends DevicePolicyUpsertArgs>(args: SelectSubset<T, DevicePolicyUpsertArgs<ExtArgs>>): Prisma__DevicePolicyClient<$Result.GetResult<Prisma.$DevicePolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DevicePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyCountArgs} args - Arguments to filter DevicePolicies to count.
     * @example
     * // Count the number of DevicePolicies
     * const count = await prisma.devicePolicy.count({
     *   where: {
     *     // ... the filter for the DevicePolicies we want to count
     *   }
     * })
    **/
    count<T extends DevicePolicyCountArgs>(
      args?: Subset<T, DevicePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevicePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DevicePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevicePolicyAggregateArgs>(args: Subset<T, DevicePolicyAggregateArgs>): Prisma.PrismaPromise<GetDevicePolicyAggregateType<T>>

    /**
     * Group by DevicePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevicePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevicePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevicePolicyGroupByArgs['orderBy'] }
        : { orderBy?: DevicePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevicePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevicePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DevicePolicy model
   */
  readonly fields: DevicePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DevicePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DevicePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    policy<T extends PolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefaultArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DevicePolicy model
   */
  interface DevicePolicyFieldRefs {
    readonly id: FieldRef<"DevicePolicy", 'Int'>
    readonly device_id: FieldRef<"DevicePolicy", 'Int'>
    readonly policy_id: FieldRef<"DevicePolicy", 'Int'>
    readonly applied_at: FieldRef<"DevicePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DevicePolicy findUnique
   */
  export type DevicePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter, which DevicePolicy to fetch.
     */
    where: DevicePolicyWhereUniqueInput
  }

  /**
   * DevicePolicy findUniqueOrThrow
   */
  export type DevicePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter, which DevicePolicy to fetch.
     */
    where: DevicePolicyWhereUniqueInput
  }

  /**
   * DevicePolicy findFirst
   */
  export type DevicePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter, which DevicePolicy to fetch.
     */
    where?: DevicePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevicePolicies to fetch.
     */
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevicePolicies.
     */
    cursor?: DevicePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevicePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevicePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevicePolicies.
     */
    distinct?: DevicePolicyScalarFieldEnum | DevicePolicyScalarFieldEnum[]
  }

  /**
   * DevicePolicy findFirstOrThrow
   */
  export type DevicePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter, which DevicePolicy to fetch.
     */
    where?: DevicePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevicePolicies to fetch.
     */
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevicePolicies.
     */
    cursor?: DevicePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevicePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevicePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevicePolicies.
     */
    distinct?: DevicePolicyScalarFieldEnum | DevicePolicyScalarFieldEnum[]
  }

  /**
   * DevicePolicy findMany
   */
  export type DevicePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter, which DevicePolicies to fetch.
     */
    where?: DevicePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevicePolicies to fetch.
     */
    orderBy?: DevicePolicyOrderByWithRelationInput | DevicePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DevicePolicies.
     */
    cursor?: DevicePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevicePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevicePolicies.
     */
    skip?: number
    distinct?: DevicePolicyScalarFieldEnum | DevicePolicyScalarFieldEnum[]
  }

  /**
   * DevicePolicy create
   */
  export type DevicePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a DevicePolicy.
     */
    data: XOR<DevicePolicyCreateInput, DevicePolicyUncheckedCreateInput>
  }

  /**
   * DevicePolicy createMany
   */
  export type DevicePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DevicePolicies.
     */
    data: DevicePolicyCreateManyInput | DevicePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DevicePolicy update
   */
  export type DevicePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a DevicePolicy.
     */
    data: XOR<DevicePolicyUpdateInput, DevicePolicyUncheckedUpdateInput>
    /**
     * Choose, which DevicePolicy to update.
     */
    where: DevicePolicyWhereUniqueInput
  }

  /**
   * DevicePolicy updateMany
   */
  export type DevicePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DevicePolicies.
     */
    data: XOR<DevicePolicyUpdateManyMutationInput, DevicePolicyUncheckedUpdateManyInput>
    /**
     * Filter which DevicePolicies to update
     */
    where?: DevicePolicyWhereInput
    /**
     * Limit how many DevicePolicies to update.
     */
    limit?: number
  }

  /**
   * DevicePolicy upsert
   */
  export type DevicePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the DevicePolicy to update in case it exists.
     */
    where: DevicePolicyWhereUniqueInput
    /**
     * In case the DevicePolicy found by the `where` argument doesn't exist, create a new DevicePolicy with this data.
     */
    create: XOR<DevicePolicyCreateInput, DevicePolicyUncheckedCreateInput>
    /**
     * In case the DevicePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DevicePolicyUpdateInput, DevicePolicyUncheckedUpdateInput>
  }

  /**
   * DevicePolicy delete
   */
  export type DevicePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
    /**
     * Filter which DevicePolicy to delete.
     */
    where: DevicePolicyWhereUniqueInput
  }

  /**
   * DevicePolicy deleteMany
   */
  export type DevicePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevicePolicies to delete
     */
    where?: DevicePolicyWhereInput
    /**
     * Limit how many DevicePolicies to delete.
     */
    limit?: number
  }

  /**
   * DevicePolicy without action
   */
  export type DevicePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevicePolicy
     */
    select?: DevicePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevicePolicy
     */
    omit?: DevicePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DevicePolicyInclude<ExtArgs> | null
  }


  /**
   * Model Command
   */

  export type AggregateCommand = {
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  export type CommandAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
  }

  export type CommandSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
  }

  export type CommandMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
    command_type: $Enums.CommandType | null
    status: $Enums.CommandStatus | null
    created_at: Date | null
    executed_at: Date | null
  }

  export type CommandMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
    command_type: $Enums.CommandType | null
    status: $Enums.CommandStatus | null
    created_at: Date | null
    executed_at: Date | null
  }

  export type CommandCountAggregateOutputType = {
    id: number
    device_id: number
    admin_id: number
    command_type: number
    payload: number
    status: number
    created_at: number
    executed_at: number
    _all: number
  }


  export type CommandAvgAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
  }

  export type CommandSumAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
  }

  export type CommandMinAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    command_type?: true
    status?: true
    created_at?: true
    executed_at?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    command_type?: true
    status?: true
    created_at?: true
    executed_at?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    command_type?: true
    payload?: true
    status?: true
    created_at?: true
    executed_at?: true
    _all?: true
  }

  export type CommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Command to aggregate.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    _count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
        [P in keyof T & keyof AggregateCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }




  export type CommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithAggregationInput | CommandOrderByWithAggregationInput[]
    by: CommandScalarFieldEnum[] | CommandScalarFieldEnum
    having?: CommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandCountAggregateInputType | true
    _avg?: CommandAvgAggregateInputType
    _sum?: CommandSumAggregateInputType
    _min?: CommandMinAggregateInputType
    _max?: CommandMaxAggregateInputType
  }

  export type CommandGroupByOutputType = {
    id: number
    device_id: number
    admin_id: number
    command_type: $Enums.CommandType
    payload: JsonValue | null
    status: $Enums.CommandStatus
    created_at: Date
    executed_at: Date | null
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  type GetCommandGroupByPayload<T extends CommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandGroupByOutputType[P]>
            : GetScalarType<T[P], CommandGroupByOutputType[P]>
        }
      >
    >


  export type CommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    admin_id?: boolean
    command_type?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
    executed_at?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>



  export type CommandSelectScalar = {
    id?: boolean
    device_id?: boolean
    admin_id?: boolean
    command_type?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
    executed_at?: boolean
  }

  export type CommandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "admin_id" | "command_type" | "payload" | "status" | "created_at" | "executed_at", ExtArgs["result"]["command"]>
  export type CommandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $CommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Command"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      admin_id: number
      command_type: $Enums.CommandType
      payload: Prisma.JsonValue | null
      status: $Enums.CommandStatus
      created_at: Date
      executed_at: Date | null
    }, ExtArgs["result"]["command"]>
    composites: {}
  }

  type CommandGetPayload<S extends boolean | null | undefined | CommandDefaultArgs> = $Result.GetResult<Prisma.$CommandPayload, S>

  type CommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandCountAggregateInputType | true
    }

  export interface CommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Command'], meta: { name: 'Command' } }
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandFindUniqueArgs>(args: SelectSubset<T, CommandFindUniqueArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Command that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandFindUniqueOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Command that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandFindFirstArgs>(args?: SelectSubset<T, CommandFindFirstArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Command that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandFindManyArgs>(args?: SelectSubset<T, CommandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
     */
    create<T extends CommandCreateArgs>(args: SelectSubset<T, CommandCreateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commands.
     * @param {CommandCreateManyArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandCreateManyArgs>(args?: SelectSubset<T, CommandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
     */
    delete<T extends CommandDeleteArgs>(args: SelectSubset<T, CommandDeleteArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandUpdateArgs>(args: SelectSubset<T, CommandUpdateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandDeleteManyArgs>(args?: SelectSubset<T, CommandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandUpdateManyArgs>(args: SelectSubset<T, CommandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
     */
    upsert<T extends CommandUpsertArgs>(args: SelectSubset<T, CommandUpsertArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): Prisma.PrismaPromise<GetCommandAggregateType<T>>

    /**
     * Group by Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandGroupByArgs['orderBy'] }
        : { orderBy?: CommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Command model
   */
  readonly fields: CommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Command model
   */
  interface CommandFieldRefs {
    readonly id: FieldRef<"Command", 'Int'>
    readonly device_id: FieldRef<"Command", 'Int'>
    readonly admin_id: FieldRef<"Command", 'Int'>
    readonly command_type: FieldRef<"Command", 'CommandType'>
    readonly payload: FieldRef<"Command", 'Json'>
    readonly status: FieldRef<"Command", 'CommandStatus'>
    readonly created_at: FieldRef<"Command", 'DateTime'>
    readonly executed_at: FieldRef<"Command", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findUniqueOrThrow
   */
  export type CommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findFirstOrThrow
   */
  export type CommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findMany
   */
  export type CommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Commands to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command create
   */
  export type CommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to create a Command.
     */
    data: XOR<CommandCreateInput, CommandUncheckedCreateInput>
  }

  /**
   * Command createMany
   */
  export type CommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Command update
   */
  export type CommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to update a Command.
     */
    data: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
    /**
     * Choose, which Command to update.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commands.
     */
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    /**
     * Filter which Commands to update
     */
    where?: CommandWhereInput
    /**
     * Limit how many Commands to update.
     */
    limit?: number
  }

  /**
   * Command upsert
   */
  export type CommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The filter to search for the Command to update in case it exists.
     */
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
     */
    create: XOR<CommandCreateInput, CommandUncheckedCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
  }

  /**
   * Command delete
   */
  export type CommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter which Command to delete.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commands to delete
     */
    where?: CommandWhereInput
    /**
     * Limit how many Commands to delete.
     */
    limit?: number
  }

  /**
   * Command without action
   */
  export type CommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Command
     */
    omit?: CommandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
    event_type: string | null
    message: string | null
    created_at: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    admin_id: number | null
    event_type: string | null
    message: string | null
    created_at: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    device_id: number
    admin_id: number
    event_type: number
    message: number
    created_at: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    event_type?: true
    message?: true
    created_at?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    event_type?: true
    message?: true
    created_at?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    device_id?: true
    admin_id?: true
    event_type?: true
    message?: true
    created_at?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    device_id: number | null
    admin_id: number | null
    event_type: string | null
    message: string | null
    created_at: Date
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    admin_id?: boolean
    event_type?: boolean
    message?: boolean
    created_at?: boolean
    device?: boolean | Log$deviceArgs<ExtArgs>
    admin?: boolean | Log$adminArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>



  export type LogSelectScalar = {
    id?: boolean
    device_id?: boolean
    admin_id?: boolean
    event_type?: boolean
    message?: boolean
    created_at?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "admin_id" | "event_type" | "message" | "created_at", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | Log$deviceArgs<ExtArgs>
    admin?: boolean | Log$adminArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number | null
      admin_id: number | null
      event_type: string | null
      message: string | null
      created_at: Date
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends Log$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Log$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends Log$adminArgs<ExtArgs> = {}>(args?: Subset<T, Log$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly device_id: FieldRef<"Log", 'Int'>
    readonly admin_id: FieldRef<"Log", 'Int'>
    readonly event_type: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly created_at: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data?: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.device
   */
  export type Log$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Log.admin
   */
  export type Log$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model App
   */

  export type AggregateApp = {
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  export type AppAvgAggregateOutputType = {
    id: number | null
  }

  export type AppSumAggregateOutputType = {
    id: number | null
  }

  export type AppMinAggregateOutputType = {
    id: number | null
    name: string | null
    package_name: string | null
    version: string | null
    source: $Enums.AppSource | null
    download_url: string | null
    created_at: Date | null
  }

  export type AppMaxAggregateOutputType = {
    id: number | null
    name: string | null
    package_name: string | null
    version: string | null
    source: $Enums.AppSource | null
    download_url: string | null
    created_at: Date | null
  }

  export type AppCountAggregateOutputType = {
    id: number
    name: number
    package_name: number
    version: number
    source: number
    download_url: number
    created_at: number
    _all: number
  }


  export type AppAvgAggregateInputType = {
    id?: true
  }

  export type AppSumAggregateInputType = {
    id?: true
  }

  export type AppMinAggregateInputType = {
    id?: true
    name?: true
    package_name?: true
    version?: true
    source?: true
    download_url?: true
    created_at?: true
  }

  export type AppMaxAggregateInputType = {
    id?: true
    name?: true
    package_name?: true
    version?: true
    source?: true
    download_url?: true
    created_at?: true
  }

  export type AppCountAggregateInputType = {
    id?: true
    name?: true
    package_name?: true
    version?: true
    source?: true
    download_url?: true
    created_at?: true
    _all?: true
  }

  export type AppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which App to aggregate.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apps
    **/
    _count?: true | AppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppMaxAggregateInputType
  }

  export type GetAppAggregateType<T extends AppAggregateArgs> = {
        [P in keyof T & keyof AggregateApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp[P]>
      : GetScalarType<T[P], AggregateApp[P]>
  }




  export type AppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWhereInput
    orderBy?: AppOrderByWithAggregationInput | AppOrderByWithAggregationInput[]
    by: AppScalarFieldEnum[] | AppScalarFieldEnum
    having?: AppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppCountAggregateInputType | true
    _avg?: AppAvgAggregateInputType
    _sum?: AppSumAggregateInputType
    _min?: AppMinAggregateInputType
    _max?: AppMaxAggregateInputType
  }

  export type AppGroupByOutputType = {
    id: number
    name: string
    package_name: string
    version: string | null
    source: $Enums.AppSource
    download_url: string | null
    created_at: Date
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  type GetAppGroupByPayload<T extends AppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppGroupByOutputType[P]>
            : GetScalarType<T[P], AppGroupByOutputType[P]>
        }
      >
    >


  export type AppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    package_name?: boolean
    version?: boolean
    source?: boolean
    download_url?: boolean
    created_at?: boolean
    deviceApps?: boolean | App$deviceAppsArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app"]>



  export type AppSelectScalar = {
    id?: boolean
    name?: boolean
    package_name?: boolean
    version?: boolean
    source?: boolean
    download_url?: boolean
    created_at?: boolean
  }

  export type AppOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "package_name" | "version" | "source" | "download_url" | "created_at", ExtArgs["result"]["app"]>
  export type AppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceApps?: boolean | App$deviceAppsArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "App"
    objects: {
      deviceApps: Prisma.$DeviceAppPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      package_name: string
      version: string | null
      source: $Enums.AppSource
      download_url: string | null
      created_at: Date
    }, ExtArgs["result"]["app"]>
    composites: {}
  }

  type AppGetPayload<S extends boolean | null | undefined | AppDefaultArgs> = $Result.GetResult<Prisma.$AppPayload, S>

  type AppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppCountAggregateInputType | true
    }

  export interface AppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['App'], meta: { name: 'App' } }
    /**
     * Find zero or one App that matches the filter.
     * @param {AppFindUniqueArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppFindUniqueArgs>(args: SelectSubset<T, AppFindUniqueArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one App that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppFindUniqueOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppFindUniqueOrThrowArgs>(args: SelectSubset<T, AppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppFindFirstArgs>(args?: SelectSubset<T, AppFindFirstArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppFindFirstOrThrowArgs>(args?: SelectSubset<T, AppFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apps
     * const apps = await prisma.app.findMany()
     * 
     * // Get first 10 Apps
     * const apps = await prisma.app.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appWithIdOnly = await prisma.app.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppFindManyArgs>(args?: SelectSubset<T, AppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a App.
     * @param {AppCreateArgs} args - Arguments to create a App.
     * @example
     * // Create one App
     * const App = await prisma.app.create({
     *   data: {
     *     // ... data to create a App
     *   }
     * })
     * 
     */
    create<T extends AppCreateArgs>(args: SelectSubset<T, AppCreateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apps.
     * @param {AppCreateManyArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const app = await prisma.app.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppCreateManyArgs>(args?: SelectSubset<T, AppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App.
     * @param {AppDeleteArgs} args - Arguments to delete one App.
     * @example
     * // Delete one App
     * const App = await prisma.app.delete({
     *   where: {
     *     // ... filter to delete one App
     *   }
     * })
     * 
     */
    delete<T extends AppDeleteArgs>(args: SelectSubset<T, AppDeleteArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one App.
     * @param {AppUpdateArgs} args - Arguments to update one App.
     * @example
     * // Update one App
     * const app = await prisma.app.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppUpdateArgs>(args: SelectSubset<T, AppUpdateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apps.
     * @param {AppDeleteManyArgs} args - Arguments to filter Apps to delete.
     * @example
     * // Delete a few Apps
     * const { count } = await prisma.app.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppDeleteManyArgs>(args?: SelectSubset<T, AppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apps
     * const app = await prisma.app.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppUpdateManyArgs>(args: SelectSubset<T, AppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App.
     * @param {AppUpsertArgs} args - Arguments to update or create a App.
     * @example
     * // Update or create a App
     * const app = await prisma.app.upsert({
     *   create: {
     *     // ... data to create a App
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App we want to update
     *   }
     * })
     */
    upsert<T extends AppUpsertArgs>(args: SelectSubset<T, AppUpsertArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppCountArgs} args - Arguments to filter Apps to count.
     * @example
     * // Count the number of Apps
     * const count = await prisma.app.count({
     *   where: {
     *     // ... the filter for the Apps we want to count
     *   }
     * })
    **/
    count<T extends AppCountArgs>(
      args?: Subset<T, AppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppAggregateArgs>(args: Subset<T, AppAggregateArgs>): Prisma.PrismaPromise<GetAppAggregateType<T>>

    /**
     * Group by App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppGroupByArgs['orderBy'] }
        : { orderBy?: AppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the App model
   */
  readonly fields: AppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for App.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceApps<T extends App$deviceAppsArgs<ExtArgs> = {}>(args?: Subset<T, App$deviceAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the App model
   */
  interface AppFieldRefs {
    readonly id: FieldRef<"App", 'Int'>
    readonly name: FieldRef<"App", 'String'>
    readonly package_name: FieldRef<"App", 'String'>
    readonly version: FieldRef<"App", 'String'>
    readonly source: FieldRef<"App", 'AppSource'>
    readonly download_url: FieldRef<"App", 'String'>
    readonly created_at: FieldRef<"App", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * App findUnique
   */
  export type AppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findUniqueOrThrow
   */
  export type AppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findFirst
   */
  export type AppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findFirstOrThrow
   */
  export type AppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findMany
   */
  export type AppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which Apps to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App create
   */
  export type AppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to create a App.
     */
    data: XOR<AppCreateInput, AppUncheckedCreateInput>
  }

  /**
   * App createMany
   */
  export type AppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apps.
     */
    data: AppCreateManyInput | AppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * App update
   */
  export type AppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to update a App.
     */
    data: XOR<AppUpdateInput, AppUncheckedUpdateInput>
    /**
     * Choose, which App to update.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App updateMany
   */
  export type AppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apps.
     */
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyInput>
    /**
     * Filter which Apps to update
     */
    where?: AppWhereInput
    /**
     * Limit how many Apps to update.
     */
    limit?: number
  }

  /**
   * App upsert
   */
  export type AppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The filter to search for the App to update in case it exists.
     */
    where: AppWhereUniqueInput
    /**
     * In case the App found by the `where` argument doesn't exist, create a new App with this data.
     */
    create: XOR<AppCreateInput, AppUncheckedCreateInput>
    /**
     * In case the App was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppUpdateInput, AppUncheckedUpdateInput>
  }

  /**
   * App delete
   */
  export type AppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter which App to delete.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App deleteMany
   */
  export type AppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apps to delete
     */
    where?: AppWhereInput
    /**
     * Limit how many Apps to delete.
     */
    limit?: number
  }

  /**
   * App.deviceApps
   */
  export type App$deviceAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    where?: DeviceAppWhereInput
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    cursor?: DeviceAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceAppScalarFieldEnum | DeviceAppScalarFieldEnum[]
  }

  /**
   * App without action
   */
  export type AppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
  }


  /**
   * Model DeviceApp
   */

  export type AggregateDeviceApp = {
    _count: DeviceAppCountAggregateOutputType | null
    _avg: DeviceAppAvgAggregateOutputType | null
    _sum: DeviceAppSumAggregateOutputType | null
    _min: DeviceAppMinAggregateOutputType | null
    _max: DeviceAppMaxAggregateOutputType | null
  }

  export type DeviceAppAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    app_id: number | null
  }

  export type DeviceAppSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    app_id: number | null
  }

  export type DeviceAppMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    app_id: number | null
    status: $Enums.DeviceAppStatus | null
  }

  export type DeviceAppMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    app_id: number | null
    status: $Enums.DeviceAppStatus | null
  }

  export type DeviceAppCountAggregateOutputType = {
    id: number
    device_id: number
    app_id: number
    status: number
    _all: number
  }


  export type DeviceAppAvgAggregateInputType = {
    id?: true
    device_id?: true
    app_id?: true
  }

  export type DeviceAppSumAggregateInputType = {
    id?: true
    device_id?: true
    app_id?: true
  }

  export type DeviceAppMinAggregateInputType = {
    id?: true
    device_id?: true
    app_id?: true
    status?: true
  }

  export type DeviceAppMaxAggregateInputType = {
    id?: true
    device_id?: true
    app_id?: true
    status?: true
  }

  export type DeviceAppCountAggregateInputType = {
    id?: true
    device_id?: true
    app_id?: true
    status?: true
    _all?: true
  }

  export type DeviceAppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceApp to aggregate.
     */
    where?: DeviceAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceApps to fetch.
     */
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceApps
    **/
    _count?: true | DeviceAppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceAppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceAppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceAppMaxAggregateInputType
  }

  export type GetDeviceAppAggregateType<T extends DeviceAppAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceApp[P]>
      : GetScalarType<T[P], AggregateDeviceApp[P]>
  }




  export type DeviceAppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceAppWhereInput
    orderBy?: DeviceAppOrderByWithAggregationInput | DeviceAppOrderByWithAggregationInput[]
    by: DeviceAppScalarFieldEnum[] | DeviceAppScalarFieldEnum
    having?: DeviceAppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceAppCountAggregateInputType | true
    _avg?: DeviceAppAvgAggregateInputType
    _sum?: DeviceAppSumAggregateInputType
    _min?: DeviceAppMinAggregateInputType
    _max?: DeviceAppMaxAggregateInputType
  }

  export type DeviceAppGroupByOutputType = {
    id: number
    device_id: number
    app_id: number
    status: $Enums.DeviceAppStatus
    _count: DeviceAppCountAggregateOutputType | null
    _avg: DeviceAppAvgAggregateOutputType | null
    _sum: DeviceAppSumAggregateOutputType | null
    _min: DeviceAppMinAggregateOutputType | null
    _max: DeviceAppMaxAggregateOutputType | null
  }

  type GetDeviceAppGroupByPayload<T extends DeviceAppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceAppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceAppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceAppGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceAppGroupByOutputType[P]>
        }
      >
    >


  export type DeviceAppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    app_id?: boolean
    status?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceApp"]>



  export type DeviceAppSelectScalar = {
    id?: boolean
    device_id?: boolean
    app_id?: boolean
    status?: boolean
  }

  export type DeviceAppOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "app_id" | "status", ExtArgs["result"]["deviceApp"]>
  export type DeviceAppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $DeviceAppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceApp"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      app_id: number
      status: $Enums.DeviceAppStatus
    }, ExtArgs["result"]["deviceApp"]>
    composites: {}
  }

  type DeviceAppGetPayload<S extends boolean | null | undefined | DeviceAppDefaultArgs> = $Result.GetResult<Prisma.$DeviceAppPayload, S>

  type DeviceAppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceAppFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceAppCountAggregateInputType | true
    }

  export interface DeviceAppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceApp'], meta: { name: 'DeviceApp' } }
    /**
     * Find zero or one DeviceApp that matches the filter.
     * @param {DeviceAppFindUniqueArgs} args - Arguments to find a DeviceApp
     * @example
     * // Get one DeviceApp
     * const deviceApp = await prisma.deviceApp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceAppFindUniqueArgs>(args: SelectSubset<T, DeviceAppFindUniqueArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceApp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceAppFindUniqueOrThrowArgs} args - Arguments to find a DeviceApp
     * @example
     * // Get one DeviceApp
     * const deviceApp = await prisma.deviceApp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceAppFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceAppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceApp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppFindFirstArgs} args - Arguments to find a DeviceApp
     * @example
     * // Get one DeviceApp
     * const deviceApp = await prisma.deviceApp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceAppFindFirstArgs>(args?: SelectSubset<T, DeviceAppFindFirstArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceApp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppFindFirstOrThrowArgs} args - Arguments to find a DeviceApp
     * @example
     * // Get one DeviceApp
     * const deviceApp = await prisma.deviceApp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceAppFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceAppFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceApps
     * const deviceApps = await prisma.deviceApp.findMany()
     * 
     * // Get first 10 DeviceApps
     * const deviceApps = await prisma.deviceApp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceAppWithIdOnly = await prisma.deviceApp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceAppFindManyArgs>(args?: SelectSubset<T, DeviceAppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceApp.
     * @param {DeviceAppCreateArgs} args - Arguments to create a DeviceApp.
     * @example
     * // Create one DeviceApp
     * const DeviceApp = await prisma.deviceApp.create({
     *   data: {
     *     // ... data to create a DeviceApp
     *   }
     * })
     * 
     */
    create<T extends DeviceAppCreateArgs>(args: SelectSubset<T, DeviceAppCreateArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceApps.
     * @param {DeviceAppCreateManyArgs} args - Arguments to create many DeviceApps.
     * @example
     * // Create many DeviceApps
     * const deviceApp = await prisma.deviceApp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceAppCreateManyArgs>(args?: SelectSubset<T, DeviceAppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceApp.
     * @param {DeviceAppDeleteArgs} args - Arguments to delete one DeviceApp.
     * @example
     * // Delete one DeviceApp
     * const DeviceApp = await prisma.deviceApp.delete({
     *   where: {
     *     // ... filter to delete one DeviceApp
     *   }
     * })
     * 
     */
    delete<T extends DeviceAppDeleteArgs>(args: SelectSubset<T, DeviceAppDeleteArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceApp.
     * @param {DeviceAppUpdateArgs} args - Arguments to update one DeviceApp.
     * @example
     * // Update one DeviceApp
     * const deviceApp = await prisma.deviceApp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceAppUpdateArgs>(args: SelectSubset<T, DeviceAppUpdateArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceApps.
     * @param {DeviceAppDeleteManyArgs} args - Arguments to filter DeviceApps to delete.
     * @example
     * // Delete a few DeviceApps
     * const { count } = await prisma.deviceApp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceAppDeleteManyArgs>(args?: SelectSubset<T, DeviceAppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceApps
     * const deviceApp = await prisma.deviceApp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceAppUpdateManyArgs>(args: SelectSubset<T, DeviceAppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceApp.
     * @param {DeviceAppUpsertArgs} args - Arguments to update or create a DeviceApp.
     * @example
     * // Update or create a DeviceApp
     * const deviceApp = await prisma.deviceApp.upsert({
     *   create: {
     *     // ... data to create a DeviceApp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceApp we want to update
     *   }
     * })
     */
    upsert<T extends DeviceAppUpsertArgs>(args: SelectSubset<T, DeviceAppUpsertArgs<ExtArgs>>): Prisma__DeviceAppClient<$Result.GetResult<Prisma.$DeviceAppPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppCountArgs} args - Arguments to filter DeviceApps to count.
     * @example
     * // Count the number of DeviceApps
     * const count = await prisma.deviceApp.count({
     *   where: {
     *     // ... the filter for the DeviceApps we want to count
     *   }
     * })
    **/
    count<T extends DeviceAppCountArgs>(
      args?: Subset<T, DeviceAppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceAppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAppAggregateArgs>(args: Subset<T, DeviceAppAggregateArgs>): Prisma.PrismaPromise<GetDeviceAppAggregateType<T>>

    /**
     * Group by DeviceApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceAppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceAppGroupByArgs['orderBy'] }
        : { orderBy?: DeviceAppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceAppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceApp model
   */
  readonly fields: DeviceAppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceApp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceAppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceApp model
   */
  interface DeviceAppFieldRefs {
    readonly id: FieldRef<"DeviceApp", 'Int'>
    readonly device_id: FieldRef<"DeviceApp", 'Int'>
    readonly app_id: FieldRef<"DeviceApp", 'Int'>
    readonly status: FieldRef<"DeviceApp", 'DeviceAppStatus'>
  }
    

  // Custom InputTypes
  /**
   * DeviceApp findUnique
   */
  export type DeviceAppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter, which DeviceApp to fetch.
     */
    where: DeviceAppWhereUniqueInput
  }

  /**
   * DeviceApp findUniqueOrThrow
   */
  export type DeviceAppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter, which DeviceApp to fetch.
     */
    where: DeviceAppWhereUniqueInput
  }

  /**
   * DeviceApp findFirst
   */
  export type DeviceAppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter, which DeviceApp to fetch.
     */
    where?: DeviceAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceApps to fetch.
     */
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceApps.
     */
    cursor?: DeviceAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceApps.
     */
    distinct?: DeviceAppScalarFieldEnum | DeviceAppScalarFieldEnum[]
  }

  /**
   * DeviceApp findFirstOrThrow
   */
  export type DeviceAppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter, which DeviceApp to fetch.
     */
    where?: DeviceAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceApps to fetch.
     */
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceApps.
     */
    cursor?: DeviceAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceApps.
     */
    distinct?: DeviceAppScalarFieldEnum | DeviceAppScalarFieldEnum[]
  }

  /**
   * DeviceApp findMany
   */
  export type DeviceAppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter, which DeviceApps to fetch.
     */
    where?: DeviceAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceApps to fetch.
     */
    orderBy?: DeviceAppOrderByWithRelationInput | DeviceAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceApps.
     */
    cursor?: DeviceAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceApps.
     */
    skip?: number
    distinct?: DeviceAppScalarFieldEnum | DeviceAppScalarFieldEnum[]
  }

  /**
   * DeviceApp create
   */
  export type DeviceAppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceApp.
     */
    data: XOR<DeviceAppCreateInput, DeviceAppUncheckedCreateInput>
  }

  /**
   * DeviceApp createMany
   */
  export type DeviceAppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceApps.
     */
    data: DeviceAppCreateManyInput | DeviceAppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceApp update
   */
  export type DeviceAppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceApp.
     */
    data: XOR<DeviceAppUpdateInput, DeviceAppUncheckedUpdateInput>
    /**
     * Choose, which DeviceApp to update.
     */
    where: DeviceAppWhereUniqueInput
  }

  /**
   * DeviceApp updateMany
   */
  export type DeviceAppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceApps.
     */
    data: XOR<DeviceAppUpdateManyMutationInput, DeviceAppUncheckedUpdateManyInput>
    /**
     * Filter which DeviceApps to update
     */
    where?: DeviceAppWhereInput
    /**
     * Limit how many DeviceApps to update.
     */
    limit?: number
  }

  /**
   * DeviceApp upsert
   */
  export type DeviceAppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceApp to update in case it exists.
     */
    where: DeviceAppWhereUniqueInput
    /**
     * In case the DeviceApp found by the `where` argument doesn't exist, create a new DeviceApp with this data.
     */
    create: XOR<DeviceAppCreateInput, DeviceAppUncheckedCreateInput>
    /**
     * In case the DeviceApp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceAppUpdateInput, DeviceAppUncheckedUpdateInput>
  }

  /**
   * DeviceApp delete
   */
  export type DeviceAppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
    /**
     * Filter which DeviceApp to delete.
     */
    where: DeviceAppWhereUniqueInput
  }

  /**
   * DeviceApp deleteMany
   */
  export type DeviceAppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceApps to delete
     */
    where?: DeviceAppWhereInput
    /**
     * Limit how many DeviceApps to delete.
     */
    limit?: number
  }

  /**
   * DeviceApp without action
   */
  export type DeviceAppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceApp
     */
    select?: DeviceAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceApp
     */
    omit?: DeviceAppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceAppInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    description: string | null
    created_at: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    deviceGroups?: boolean | Group$deviceGroupsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>



  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "created_at", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceGroups?: boolean | Group$deviceGroupsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      deviceGroups: Prisma.$DeviceGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      created_at: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceGroups<T extends Group$deviceGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Group$deviceGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly created_at: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.deviceGroups
   */
  export type Group$deviceGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    where?: DeviceGroupWhereInput
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    cursor?: DeviceGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupScalarFieldEnum | DeviceGroupScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model DeviceGroup
   */

  export type AggregateDeviceGroup = {
    _count: DeviceGroupCountAggregateOutputType | null
    _avg: DeviceGroupAvgAggregateOutputType | null
    _sum: DeviceGroupSumAggregateOutputType | null
    _min: DeviceGroupMinAggregateOutputType | null
    _max: DeviceGroupMaxAggregateOutputType | null
  }

  export type DeviceGroupAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    group_id: number | null
  }

  export type DeviceGroupSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    group_id: number | null
  }

  export type DeviceGroupMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    group_id: number | null
  }

  export type DeviceGroupMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    group_id: number | null
  }

  export type DeviceGroupCountAggregateOutputType = {
    id: number
    device_id: number
    group_id: number
    _all: number
  }


  export type DeviceGroupAvgAggregateInputType = {
    id?: true
    device_id?: true
    group_id?: true
  }

  export type DeviceGroupSumAggregateInputType = {
    id?: true
    device_id?: true
    group_id?: true
  }

  export type DeviceGroupMinAggregateInputType = {
    id?: true
    device_id?: true
    group_id?: true
  }

  export type DeviceGroupMaxAggregateInputType = {
    id?: true
    device_id?: true
    group_id?: true
  }

  export type DeviceGroupCountAggregateInputType = {
    id?: true
    device_id?: true
    group_id?: true
    _all?: true
  }

  export type DeviceGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroup to aggregate.
     */
    where?: DeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroups to fetch.
     */
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceGroups
    **/
    _count?: true | DeviceGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceGroupMaxAggregateInputType
  }

  export type GetDeviceGroupAggregateType<T extends DeviceGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceGroup[P]>
      : GetScalarType<T[P], AggregateDeviceGroup[P]>
  }




  export type DeviceGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupWhereInput
    orderBy?: DeviceGroupOrderByWithAggregationInput | DeviceGroupOrderByWithAggregationInput[]
    by: DeviceGroupScalarFieldEnum[] | DeviceGroupScalarFieldEnum
    having?: DeviceGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceGroupCountAggregateInputType | true
    _avg?: DeviceGroupAvgAggregateInputType
    _sum?: DeviceGroupSumAggregateInputType
    _min?: DeviceGroupMinAggregateInputType
    _max?: DeviceGroupMaxAggregateInputType
  }

  export type DeviceGroupGroupByOutputType = {
    id: number
    device_id: number
    group_id: number
    _count: DeviceGroupCountAggregateOutputType | null
    _avg: DeviceGroupAvgAggregateOutputType | null
    _sum: DeviceGroupSumAggregateOutputType | null
    _min: DeviceGroupMinAggregateOutputType | null
    _max: DeviceGroupMaxAggregateOutputType | null
  }

  type GetDeviceGroupGroupByPayload<T extends DeviceGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupGroupByOutputType[P]>
        }
      >
    >


  export type DeviceGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    group_id?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroup"]>



  export type DeviceGroupSelectScalar = {
    id?: boolean
    device_id?: boolean
    group_id?: boolean
  }

  export type DeviceGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "group_id", ExtArgs["result"]["deviceGroup"]>
  export type DeviceGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $DeviceGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceGroup"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      group_id: number
    }, ExtArgs["result"]["deviceGroup"]>
    composites: {}
  }

  type DeviceGroupGetPayload<S extends boolean | null | undefined | DeviceGroupDefaultArgs> = $Result.GetResult<Prisma.$DeviceGroupPayload, S>

  type DeviceGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceGroupCountAggregateInputType | true
    }

  export interface DeviceGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceGroup'], meta: { name: 'DeviceGroup' } }
    /**
     * Find zero or one DeviceGroup that matches the filter.
     * @param {DeviceGroupFindUniqueArgs} args - Arguments to find a DeviceGroup
     * @example
     * // Get one DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceGroupFindUniqueArgs>(args: SelectSubset<T, DeviceGroupFindUniqueArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceGroupFindUniqueOrThrowArgs} args - Arguments to find a DeviceGroup
     * @example
     * // Get one DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupFindFirstArgs} args - Arguments to find a DeviceGroup
     * @example
     * // Get one DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceGroupFindFirstArgs>(args?: SelectSubset<T, DeviceGroupFindFirstArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupFindFirstOrThrowArgs} args - Arguments to find a DeviceGroup
     * @example
     * // Get one DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceGroups
     * const deviceGroups = await prisma.deviceGroup.findMany()
     * 
     * // Get first 10 DeviceGroups
     * const deviceGroups = await prisma.deviceGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceGroupWithIdOnly = await prisma.deviceGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceGroupFindManyArgs>(args?: SelectSubset<T, DeviceGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceGroup.
     * @param {DeviceGroupCreateArgs} args - Arguments to create a DeviceGroup.
     * @example
     * // Create one DeviceGroup
     * const DeviceGroup = await prisma.deviceGroup.create({
     *   data: {
     *     // ... data to create a DeviceGroup
     *   }
     * })
     * 
     */
    create<T extends DeviceGroupCreateArgs>(args: SelectSubset<T, DeviceGroupCreateArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceGroups.
     * @param {DeviceGroupCreateManyArgs} args - Arguments to create many DeviceGroups.
     * @example
     * // Create many DeviceGroups
     * const deviceGroup = await prisma.deviceGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceGroupCreateManyArgs>(args?: SelectSubset<T, DeviceGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceGroup.
     * @param {DeviceGroupDeleteArgs} args - Arguments to delete one DeviceGroup.
     * @example
     * // Delete one DeviceGroup
     * const DeviceGroup = await prisma.deviceGroup.delete({
     *   where: {
     *     // ... filter to delete one DeviceGroup
     *   }
     * })
     * 
     */
    delete<T extends DeviceGroupDeleteArgs>(args: SelectSubset<T, DeviceGroupDeleteArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceGroup.
     * @param {DeviceGroupUpdateArgs} args - Arguments to update one DeviceGroup.
     * @example
     * // Update one DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceGroupUpdateArgs>(args: SelectSubset<T, DeviceGroupUpdateArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceGroups.
     * @param {DeviceGroupDeleteManyArgs} args - Arguments to filter DeviceGroups to delete.
     * @example
     * // Delete a few DeviceGroups
     * const { count } = await prisma.deviceGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceGroupDeleteManyArgs>(args?: SelectSubset<T, DeviceGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceGroups
     * const deviceGroup = await prisma.deviceGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceGroupUpdateManyArgs>(args: SelectSubset<T, DeviceGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceGroup.
     * @param {DeviceGroupUpsertArgs} args - Arguments to update or create a DeviceGroup.
     * @example
     * // Update or create a DeviceGroup
     * const deviceGroup = await prisma.deviceGroup.upsert({
     *   create: {
     *     // ... data to create a DeviceGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceGroup we want to update
     *   }
     * })
     */
    upsert<T extends DeviceGroupUpsertArgs>(args: SelectSubset<T, DeviceGroupUpsertArgs<ExtArgs>>): Prisma__DeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupCountArgs} args - Arguments to filter DeviceGroups to count.
     * @example
     * // Count the number of DeviceGroups
     * const count = await prisma.deviceGroup.count({
     *   where: {
     *     // ... the filter for the DeviceGroups we want to count
     *   }
     * })
    **/
    count<T extends DeviceGroupCountArgs>(
      args?: Subset<T, DeviceGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceGroupAggregateArgs>(args: Subset<T, DeviceGroupAggregateArgs>): Prisma.PrismaPromise<GetDeviceGroupAggregateType<T>>

    /**
     * Group by DeviceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceGroup model
   */
  readonly fields: DeviceGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceGroup model
   */
  interface DeviceGroupFieldRefs {
    readonly id: FieldRef<"DeviceGroup", 'Int'>
    readonly device_id: FieldRef<"DeviceGroup", 'Int'>
    readonly group_id: FieldRef<"DeviceGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceGroup findUnique
   */
  export type DeviceGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroup to fetch.
     */
    where: DeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroup findUniqueOrThrow
   */
  export type DeviceGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroup to fetch.
     */
    where: DeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroup findFirst
   */
  export type DeviceGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroup to fetch.
     */
    where?: DeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroups to fetch.
     */
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroups.
     */
    cursor?: DeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroups.
     */
    distinct?: DeviceGroupScalarFieldEnum | DeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroup findFirstOrThrow
   */
  export type DeviceGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroup to fetch.
     */
    where?: DeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroups to fetch.
     */
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroups.
     */
    cursor?: DeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroups.
     */
    distinct?: DeviceGroupScalarFieldEnum | DeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroup findMany
   */
  export type DeviceGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroups to fetch.
     */
    where?: DeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroups to fetch.
     */
    orderBy?: DeviceGroupOrderByWithRelationInput | DeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceGroups.
     */
    cursor?: DeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroups.
     */
    skip?: number
    distinct?: DeviceGroupScalarFieldEnum | DeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroup create
   */
  export type DeviceGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceGroup.
     */
    data: XOR<DeviceGroupCreateInput, DeviceGroupUncheckedCreateInput>
  }

  /**
   * DeviceGroup createMany
   */
  export type DeviceGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceGroups.
     */
    data: DeviceGroupCreateManyInput | DeviceGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceGroup update
   */
  export type DeviceGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceGroup.
     */
    data: XOR<DeviceGroupUpdateInput, DeviceGroupUncheckedUpdateInput>
    /**
     * Choose, which DeviceGroup to update.
     */
    where: DeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroup updateMany
   */
  export type DeviceGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceGroups.
     */
    data: XOR<DeviceGroupUpdateManyMutationInput, DeviceGroupUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroups to update
     */
    where?: DeviceGroupWhereInput
    /**
     * Limit how many DeviceGroups to update.
     */
    limit?: number
  }

  /**
   * DeviceGroup upsert
   */
  export type DeviceGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceGroup to update in case it exists.
     */
    where: DeviceGroupWhereUniqueInput
    /**
     * In case the DeviceGroup found by the `where` argument doesn't exist, create a new DeviceGroup with this data.
     */
    create: XOR<DeviceGroupCreateInput, DeviceGroupUncheckedCreateInput>
    /**
     * In case the DeviceGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceGroupUpdateInput, DeviceGroupUncheckedUpdateInput>
  }

  /**
   * DeviceGroup delete
   */
  export type DeviceGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
    /**
     * Filter which DeviceGroup to delete.
     */
    where: DeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroup deleteMany
   */
  export type DeviceGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroups to delete
     */
    where?: DeviceGroupWhereInput
    /**
     * Limit how many DeviceGroups to delete.
     */
    limit?: number
  }

  /**
   * DeviceGroup without action
   */
  export type DeviceGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroup
     */
    select?: DeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroup
     */
    omit?: DeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type AlertSumAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    alert_type: $Enums.AlertType | null
    severity: $Enums.AlertSeverity | null
    message: string | null
    created_at: Date | null
    resolved: boolean | null
  }

  export type AlertMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    alert_type: $Enums.AlertType | null
    severity: $Enums.AlertSeverity | null
    message: string | null
    created_at: Date | null
    resolved: boolean | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    device_id: number
    alert_type: number
    severity: number
    message: number
    created_at: number
    resolved: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type AlertSumAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    device_id?: true
    alert_type?: true
    severity?: true
    message?: true
    created_at?: true
    resolved?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    device_id?: true
    alert_type?: true
    severity?: true
    message?: true
    created_at?: true
    resolved?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    device_id?: true
    alert_type?: true
    severity?: true
    message?: true
    created_at?: true
    resolved?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: number
    device_id: number
    alert_type: $Enums.AlertType
    severity: $Enums.AlertSeverity
    message: string | null
    created_at: Date
    resolved: boolean
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    alert_type?: boolean
    severity?: boolean
    message?: boolean
    created_at?: boolean
    resolved?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>



  export type AlertSelectScalar = {
    id?: boolean
    device_id?: boolean
    alert_type?: boolean
    severity?: boolean
    message?: boolean
    created_at?: boolean
    resolved?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "alert_type" | "severity" | "message" | "created_at" | "resolved", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      alert_type: $Enums.AlertType
      severity: $Enums.AlertSeverity
      message: string | null
      created_at: Date
      resolved: boolean
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'Int'>
    readonly device_id: FieldRef<"Alert", 'Int'>
    readonly alert_type: FieldRef<"Alert", 'AlertType'>
    readonly severity: FieldRef<"Alert", 'AlertSeverity'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly created_at: FieldRef<"Alert", 'DateTime'>
    readonly resolved: FieldRef<"Alert", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    created_at: 'created_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    serial_number: 'serial_number',
    model: 'model',
    brand: 'brand',
    os_version: 'os_version',
    enrolled_at: 'enrolled_at',
    last_seen: 'last_seen',
    battery_level: 'battery_level',
    network_status: 'network_status',
    status: 'status'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceLocationScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    latitude: 'latitude',
    longitude: 'longitude',
    recorded_at: 'recorded_at'
  };

  export type DeviceLocationScalarFieldEnum = (typeof DeviceLocationScalarFieldEnum)[keyof typeof DeviceLocationScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    allow_camera: 'allow_camera',
    allow_wifi: 'allow_wifi',
    allow_bluetooth: 'allow_bluetooth',
    require_password: 'require_password',
    kiosk_mode: 'kiosk_mode',
    created_at: 'created_at'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const DevicePolicyScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    policy_id: 'policy_id',
    applied_at: 'applied_at'
  };

  export type DevicePolicyScalarFieldEnum = (typeof DevicePolicyScalarFieldEnum)[keyof typeof DevicePolicyScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    admin_id: 'admin_id',
    command_type: 'command_type',
    payload: 'payload',
    status: 'status',
    created_at: 'created_at',
    executed_at: 'executed_at'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    admin_id: 'admin_id',
    event_type: 'event_type',
    message: 'message',
    created_at: 'created_at'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const AppScalarFieldEnum: {
    id: 'id',
    name: 'name',
    package_name: 'package_name',
    version: 'version',
    source: 'source',
    download_url: 'download_url',
    created_at: 'created_at'
  };

  export type AppScalarFieldEnum = (typeof AppScalarFieldEnum)[keyof typeof AppScalarFieldEnum]


  export const DeviceAppScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    app_id: 'app_id',
    status: 'status'
  };

  export type DeviceAppScalarFieldEnum = (typeof DeviceAppScalarFieldEnum)[keyof typeof DeviceAppScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const DeviceGroupScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    group_id: 'group_id'
  };

  export type DeviceGroupScalarFieldEnum = (typeof DeviceGroupScalarFieldEnum)[keyof typeof DeviceGroupScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    alert_type: 'alert_type',
    severity: 'severity',
    message: 'message',
    created_at: 'created_at',
    resolved: 'resolved'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const AdminOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password_hash: 'password_hash'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const DeviceOrderByRelevanceFieldEnum: {
    device_id: 'device_id',
    serial_number: 'serial_number',
    model: 'model',
    brand: 'brand',
    os_version: 'os_version',
    network_status: 'network_status'
  };

  export type DeviceOrderByRelevanceFieldEnum = (typeof DeviceOrderByRelevanceFieldEnum)[keyof typeof DeviceOrderByRelevanceFieldEnum]


  export const PolicyOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type PolicyOrderByRelevanceFieldEnum = (typeof PolicyOrderByRelevanceFieldEnum)[keyof typeof PolicyOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const LogOrderByRelevanceFieldEnum: {
    event_type: 'event_type',
    message: 'message'
  };

  export type LogOrderByRelevanceFieldEnum = (typeof LogOrderByRelevanceFieldEnum)[keyof typeof LogOrderByRelevanceFieldEnum]


  export const AppOrderByRelevanceFieldEnum: {
    name: 'name',
    package_name: 'package_name',
    version: 'version',
    download_url: 'download_url'
  };

  export type AppOrderByRelevanceFieldEnum = (typeof AppOrderByRelevanceFieldEnum)[keyof typeof AppOrderByRelevanceFieldEnum]


  export const GroupOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type GroupOrderByRelevanceFieldEnum = (typeof GroupOrderByRelevanceFieldEnum)[keyof typeof GroupOrderByRelevanceFieldEnum]


  export const AlertOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type AlertOrderByRelevanceFieldEnum = (typeof AlertOrderByRelevanceFieldEnum)[keyof typeof AlertOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DeviceStatus'
   */
  export type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CommandType'
   */
  export type EnumCommandTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CommandStatus'
   */
  export type EnumCommandStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandStatus'>
    


  /**
   * Reference to a field of type 'AppSource'
   */
  export type EnumAppSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppSource'>
    


  /**
   * Reference to a field of type 'DeviceAppStatus'
   */
  export type EnumDeviceAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceAppStatus'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertSeverity'
   */
  export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    username?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password_hash?: StringFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    created_at?: DateTimeFilter<"Admin"> | Date | string
    commands?: CommandListRelationFilter
    logs?: LogListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    commands?: CommandOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    password_hash?: StringFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    created_at?: DateTimeFilter<"Admin"> | Date | string
    commands?: CommandListRelationFilter
    logs?: LogListRelationFilter
  }, "id" | "username" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    username?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password_hash?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumRoleWithAggregatesFilter<"Admin"> | $Enums.Role
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: IntFilter<"Device"> | number
    device_id?: StringFilter<"Device"> | string
    serial_number?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    brand?: StringNullableFilter<"Device"> | string | null
    os_version?: StringNullableFilter<"Device"> | string | null
    enrolled_at?: DateTimeFilter<"Device"> | Date | string
    last_seen?: DateTimeNullableFilter<"Device"> | Date | string | null
    battery_level?: IntNullableFilter<"Device"> | number | null
    network_status?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    locations?: DeviceLocationListRelationFilter
    devicePolicies?: DevicePolicyListRelationFilter
    commands?: CommandListRelationFilter
    deviceApps?: DeviceAppListRelationFilter
    deviceGroups?: DeviceGroupListRelationFilter
    alerts?: AlertListRelationFilter
    logs?: LogListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    os_version?: SortOrderInput | SortOrder
    enrolled_at?: SortOrder
    last_seen?: SortOrderInput | SortOrder
    battery_level?: SortOrderInput | SortOrder
    network_status?: SortOrderInput | SortOrder
    status?: SortOrder
    locations?: DeviceLocationOrderByRelationAggregateInput
    devicePolicies?: DevicePolicyOrderByRelationAggregateInput
    commands?: CommandOrderByRelationAggregateInput
    deviceApps?: DeviceAppOrderByRelationAggregateInput
    deviceGroups?: DeviceGroupOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    _relevance?: DeviceOrderByRelevanceInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    device_id?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    serial_number?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    brand?: StringNullableFilter<"Device"> | string | null
    os_version?: StringNullableFilter<"Device"> | string | null
    enrolled_at?: DateTimeFilter<"Device"> | Date | string
    last_seen?: DateTimeNullableFilter<"Device"> | Date | string | null
    battery_level?: IntNullableFilter<"Device"> | number | null
    network_status?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    locations?: DeviceLocationListRelationFilter
    devicePolicies?: DevicePolicyListRelationFilter
    commands?: CommandListRelationFilter
    deviceApps?: DeviceAppListRelationFilter
    deviceGroups?: DeviceGroupListRelationFilter
    alerts?: AlertListRelationFilter
    logs?: LogListRelationFilter
  }, "id" | "device_id">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    serial_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    os_version?: SortOrderInput | SortOrder
    enrolled_at?: SortOrder
    last_seen?: SortOrderInput | SortOrder
    battery_level?: SortOrderInput | SortOrder
    network_status?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Device"> | number
    device_id?: StringWithAggregatesFilter<"Device"> | string
    serial_number?: StringNullableWithAggregatesFilter<"Device"> | string | null
    model?: StringNullableWithAggregatesFilter<"Device"> | string | null
    brand?: StringNullableWithAggregatesFilter<"Device"> | string | null
    os_version?: StringNullableWithAggregatesFilter<"Device"> | string | null
    enrolled_at?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    last_seen?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    battery_level?: IntNullableWithAggregatesFilter<"Device"> | number | null
    network_status?: StringNullableWithAggregatesFilter<"Device"> | string | null
    status?: EnumDeviceStatusWithAggregatesFilter<"Device"> | $Enums.DeviceStatus
  }

  export type DeviceLocationWhereInput = {
    AND?: DeviceLocationWhereInput | DeviceLocationWhereInput[]
    OR?: DeviceLocationWhereInput[]
    NOT?: DeviceLocationWhereInput | DeviceLocationWhereInput[]
    id?: IntFilter<"DeviceLocation"> | number
    device_id?: IntFilter<"DeviceLocation"> | number
    latitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFilter<"DeviceLocation"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }

  export type DeviceLocationOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    recorded_at?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type DeviceLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceLocationWhereInput | DeviceLocationWhereInput[]
    OR?: DeviceLocationWhereInput[]
    NOT?: DeviceLocationWhereInput | DeviceLocationWhereInput[]
    device_id?: IntFilter<"DeviceLocation"> | number
    latitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFilter<"DeviceLocation"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }, "id">

  export type DeviceLocationOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    recorded_at?: SortOrder
    _count?: DeviceLocationCountOrderByAggregateInput
    _avg?: DeviceLocationAvgOrderByAggregateInput
    _max?: DeviceLocationMaxOrderByAggregateInput
    _min?: DeviceLocationMinOrderByAggregateInput
    _sum?: DeviceLocationSumOrderByAggregateInput
  }

  export type DeviceLocationScalarWhereWithAggregatesInput = {
    AND?: DeviceLocationScalarWhereWithAggregatesInput | DeviceLocationScalarWhereWithAggregatesInput[]
    OR?: DeviceLocationScalarWhereWithAggregatesInput[]
    NOT?: DeviceLocationScalarWhereWithAggregatesInput | DeviceLocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceLocation"> | number
    device_id?: IntWithAggregatesFilter<"DeviceLocation"> | number
    latitude?: DecimalNullableWithAggregatesFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeWithAggregatesFilter<"DeviceLocation"> | Date | string
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: IntFilter<"Policy"> | number
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    allow_camera?: BoolFilter<"Policy"> | boolean
    allow_wifi?: BoolFilter<"Policy"> | boolean
    allow_bluetooth?: BoolFilter<"Policy"> | boolean
    require_password?: BoolFilter<"Policy"> | boolean
    kiosk_mode?: BoolFilter<"Policy"> | boolean
    created_at?: DateTimeFilter<"Policy"> | Date | string
    devicePolicies?: DevicePolicyListRelationFilter
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    allow_camera?: SortOrder
    allow_wifi?: SortOrder
    allow_bluetooth?: SortOrder
    require_password?: SortOrder
    kiosk_mode?: SortOrder
    created_at?: SortOrder
    devicePolicies?: DevicePolicyOrderByRelationAggregateInput
    _relevance?: PolicyOrderByRelevanceInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    allow_camera?: BoolFilter<"Policy"> | boolean
    allow_wifi?: BoolFilter<"Policy"> | boolean
    allow_bluetooth?: BoolFilter<"Policy"> | boolean
    require_password?: BoolFilter<"Policy"> | boolean
    kiosk_mode?: BoolFilter<"Policy"> | boolean
    created_at?: DateTimeFilter<"Policy"> | Date | string
    devicePolicies?: DevicePolicyListRelationFilter
  }, "id">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    allow_camera?: SortOrder
    allow_wifi?: SortOrder
    allow_bluetooth?: SortOrder
    require_password?: SortOrder
    kiosk_mode?: SortOrder
    created_at?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Policy"> | number
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    allow_camera?: BoolWithAggregatesFilter<"Policy"> | boolean
    allow_wifi?: BoolWithAggregatesFilter<"Policy"> | boolean
    allow_bluetooth?: BoolWithAggregatesFilter<"Policy"> | boolean
    require_password?: BoolWithAggregatesFilter<"Policy"> | boolean
    kiosk_mode?: BoolWithAggregatesFilter<"Policy"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type DevicePolicyWhereInput = {
    AND?: DevicePolicyWhereInput | DevicePolicyWhereInput[]
    OR?: DevicePolicyWhereInput[]
    NOT?: DevicePolicyWhereInput | DevicePolicyWhereInput[]
    id?: IntFilter<"DevicePolicy"> | number
    device_id?: IntFilter<"DevicePolicy"> | number
    policy_id?: IntFilter<"DevicePolicy"> | number
    applied_at?: DateTimeFilter<"DevicePolicy"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
  }

  export type DevicePolicyOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
    applied_at?: SortOrder
    device?: DeviceOrderByWithRelationInput
    policy?: PolicyOrderByWithRelationInput
  }

  export type DevicePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DevicePolicyWhereInput | DevicePolicyWhereInput[]
    OR?: DevicePolicyWhereInput[]
    NOT?: DevicePolicyWhereInput | DevicePolicyWhereInput[]
    device_id?: IntFilter<"DevicePolicy"> | number
    policy_id?: IntFilter<"DevicePolicy"> | number
    applied_at?: DateTimeFilter<"DevicePolicy"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
  }, "id">

  export type DevicePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
    applied_at?: SortOrder
    _count?: DevicePolicyCountOrderByAggregateInput
    _avg?: DevicePolicyAvgOrderByAggregateInput
    _max?: DevicePolicyMaxOrderByAggregateInput
    _min?: DevicePolicyMinOrderByAggregateInput
    _sum?: DevicePolicySumOrderByAggregateInput
  }

  export type DevicePolicyScalarWhereWithAggregatesInput = {
    AND?: DevicePolicyScalarWhereWithAggregatesInput | DevicePolicyScalarWhereWithAggregatesInput[]
    OR?: DevicePolicyScalarWhereWithAggregatesInput[]
    NOT?: DevicePolicyScalarWhereWithAggregatesInput | DevicePolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DevicePolicy"> | number
    device_id?: IntWithAggregatesFilter<"DevicePolicy"> | number
    policy_id?: IntWithAggregatesFilter<"DevicePolicy"> | number
    applied_at?: DateTimeWithAggregatesFilter<"DevicePolicy"> | Date | string
  }

  export type CommandWhereInput = {
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    id?: IntFilter<"Command"> | number
    device_id?: IntFilter<"Command"> | number
    admin_id?: IntFilter<"Command"> | number
    command_type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonNullableFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    created_at?: DateTimeFilter<"Command"> | Date | string
    executed_at?: DateTimeNullableFilter<"Command"> | Date | string | null
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type CommandOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    command_type?: SortOrder
    payload?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type CommandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    device_id?: IntFilter<"Command"> | number
    admin_id?: IntFilter<"Command"> | number
    command_type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonNullableFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    created_at?: DateTimeFilter<"Command"> | Date | string
    executed_at?: DateTimeNullableFilter<"Command"> | Date | string | null
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type CommandOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    command_type?: SortOrder
    payload?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    _count?: CommandCountOrderByAggregateInput
    _avg?: CommandAvgOrderByAggregateInput
    _max?: CommandMaxOrderByAggregateInput
    _min?: CommandMinOrderByAggregateInput
    _sum?: CommandSumOrderByAggregateInput
  }

  export type CommandScalarWhereWithAggregatesInput = {
    AND?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    OR?: CommandScalarWhereWithAggregatesInput[]
    NOT?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Command"> | number
    device_id?: IntWithAggregatesFilter<"Command"> | number
    admin_id?: IntWithAggregatesFilter<"Command"> | number
    command_type?: EnumCommandTypeWithAggregatesFilter<"Command"> | $Enums.CommandType
    payload?: JsonNullableWithAggregatesFilter<"Command">
    status?: EnumCommandStatusWithAggregatesFilter<"Command"> | $Enums.CommandStatus
    created_at?: DateTimeWithAggregatesFilter<"Command"> | Date | string
    executed_at?: DateTimeNullableWithAggregatesFilter<"Command"> | Date | string | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    device_id?: IntNullableFilter<"Log"> | number | null
    admin_id?: IntNullableFilter<"Log"> | number | null
    event_type?: StringNullableFilter<"Log"> | string | null
    message?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    device?: DeviceOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    _relevance?: LogOrderByRelevanceInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    device_id?: IntNullableFilter<"Log"> | number | null
    admin_id?: IntNullableFilter<"Log"> | number | null
    event_type?: StringNullableFilter<"Log"> | string | null
    message?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    device_id?: IntNullableWithAggregatesFilter<"Log"> | number | null
    admin_id?: IntNullableWithAggregatesFilter<"Log"> | number | null
    event_type?: StringNullableWithAggregatesFilter<"Log"> | string | null
    message?: StringNullableWithAggregatesFilter<"Log"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Log"> | Date | string
  }

  export type AppWhereInput = {
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    id?: IntFilter<"App"> | number
    name?: StringFilter<"App"> | string
    package_name?: StringFilter<"App"> | string
    version?: StringNullableFilter<"App"> | string | null
    source?: EnumAppSourceFilter<"App"> | $Enums.AppSource
    download_url?: StringNullableFilter<"App"> | string | null
    created_at?: DateTimeFilter<"App"> | Date | string
    deviceApps?: DeviceAppListRelationFilter
  }

  export type AppOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    package_name?: SortOrder
    version?: SortOrderInput | SortOrder
    source?: SortOrder
    download_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deviceApps?: DeviceAppOrderByRelationAggregateInput
    _relevance?: AppOrderByRelevanceInput
  }

  export type AppWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    name?: StringFilter<"App"> | string
    package_name?: StringFilter<"App"> | string
    version?: StringNullableFilter<"App"> | string | null
    source?: EnumAppSourceFilter<"App"> | $Enums.AppSource
    download_url?: StringNullableFilter<"App"> | string | null
    created_at?: DateTimeFilter<"App"> | Date | string
    deviceApps?: DeviceAppListRelationFilter
  }, "id">

  export type AppOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    package_name?: SortOrder
    version?: SortOrderInput | SortOrder
    source?: SortOrder
    download_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: AppCountOrderByAggregateInput
    _avg?: AppAvgOrderByAggregateInput
    _max?: AppMaxOrderByAggregateInput
    _min?: AppMinOrderByAggregateInput
    _sum?: AppSumOrderByAggregateInput
  }

  export type AppScalarWhereWithAggregatesInput = {
    AND?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    OR?: AppScalarWhereWithAggregatesInput[]
    NOT?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"App"> | number
    name?: StringWithAggregatesFilter<"App"> | string
    package_name?: StringWithAggregatesFilter<"App"> | string
    version?: StringNullableWithAggregatesFilter<"App"> | string | null
    source?: EnumAppSourceWithAggregatesFilter<"App"> | $Enums.AppSource
    download_url?: StringNullableWithAggregatesFilter<"App"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"App"> | Date | string
  }

  export type DeviceAppWhereInput = {
    AND?: DeviceAppWhereInput | DeviceAppWhereInput[]
    OR?: DeviceAppWhereInput[]
    NOT?: DeviceAppWhereInput | DeviceAppWhereInput[]
    id?: IntFilter<"DeviceApp"> | number
    device_id?: IntFilter<"DeviceApp"> | number
    app_id?: IntFilter<"DeviceApp"> | number
    status?: EnumDeviceAppStatusFilter<"DeviceApp"> | $Enums.DeviceAppStatus
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type DeviceAppOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
    status?: SortOrder
    device?: DeviceOrderByWithRelationInput
    app?: AppOrderByWithRelationInput
  }

  export type DeviceAppWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceAppWhereInput | DeviceAppWhereInput[]
    OR?: DeviceAppWhereInput[]
    NOT?: DeviceAppWhereInput | DeviceAppWhereInput[]
    device_id?: IntFilter<"DeviceApp"> | number
    app_id?: IntFilter<"DeviceApp"> | number
    status?: EnumDeviceAppStatusFilter<"DeviceApp"> | $Enums.DeviceAppStatus
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type DeviceAppOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
    status?: SortOrder
    _count?: DeviceAppCountOrderByAggregateInput
    _avg?: DeviceAppAvgOrderByAggregateInput
    _max?: DeviceAppMaxOrderByAggregateInput
    _min?: DeviceAppMinOrderByAggregateInput
    _sum?: DeviceAppSumOrderByAggregateInput
  }

  export type DeviceAppScalarWhereWithAggregatesInput = {
    AND?: DeviceAppScalarWhereWithAggregatesInput | DeviceAppScalarWhereWithAggregatesInput[]
    OR?: DeviceAppScalarWhereWithAggregatesInput[]
    NOT?: DeviceAppScalarWhereWithAggregatesInput | DeviceAppScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceApp"> | number
    device_id?: IntWithAggregatesFilter<"DeviceApp"> | number
    app_id?: IntWithAggregatesFilter<"DeviceApp"> | number
    status?: EnumDeviceAppStatusWithAggregatesFilter<"DeviceApp"> | $Enums.DeviceAppStatus
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    created_at?: DateTimeFilter<"Group"> | Date | string
    deviceGroups?: DeviceGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deviceGroups?: DeviceGroupOrderByRelationAggregateInput
    _relevance?: GroupOrderByRelevanceInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    created_at?: DateTimeFilter<"Group"> | Date | string
    deviceGroups?: DeviceGroupListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type DeviceGroupWhereInput = {
    AND?: DeviceGroupWhereInput | DeviceGroupWhereInput[]
    OR?: DeviceGroupWhereInput[]
    NOT?: DeviceGroupWhereInput | DeviceGroupWhereInput[]
    id?: IntFilter<"DeviceGroup"> | number
    device_id?: IntFilter<"DeviceGroup"> | number
    group_id?: IntFilter<"DeviceGroup"> | number
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type DeviceGroupOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type DeviceGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceGroupWhereInput | DeviceGroupWhereInput[]
    OR?: DeviceGroupWhereInput[]
    NOT?: DeviceGroupWhereInput | DeviceGroupWhereInput[]
    device_id?: IntFilter<"DeviceGroup"> | number
    group_id?: IntFilter<"DeviceGroup"> | number
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id">

  export type DeviceGroupOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
    _count?: DeviceGroupCountOrderByAggregateInput
    _avg?: DeviceGroupAvgOrderByAggregateInput
    _max?: DeviceGroupMaxOrderByAggregateInput
    _min?: DeviceGroupMinOrderByAggregateInput
    _sum?: DeviceGroupSumOrderByAggregateInput
  }

  export type DeviceGroupScalarWhereWithAggregatesInput = {
    AND?: DeviceGroupScalarWhereWithAggregatesInput | DeviceGroupScalarWhereWithAggregatesInput[]
    OR?: DeviceGroupScalarWhereWithAggregatesInput[]
    NOT?: DeviceGroupScalarWhereWithAggregatesInput | DeviceGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceGroup"> | number
    device_id?: IntWithAggregatesFilter<"DeviceGroup"> | number
    group_id?: IntWithAggregatesFilter<"DeviceGroup"> | number
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: IntFilter<"Alert"> | number
    device_id?: IntFilter<"Alert"> | number
    alert_type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    message?: StringNullableFilter<"Alert"> | string | null
    created_at?: DateTimeFilter<"Alert"> | Date | string
    resolved?: BoolFilter<"Alert"> | boolean
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    alert_type?: SortOrder
    severity?: SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    resolved?: SortOrder
    device?: DeviceOrderByWithRelationInput
    _relevance?: AlertOrderByRelevanceInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    device_id?: IntFilter<"Alert"> | number
    alert_type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    message?: StringNullableFilter<"Alert"> | string | null
    created_at?: DateTimeFilter<"Alert"> | Date | string
    resolved?: BoolFilter<"Alert"> | boolean
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    alert_type?: SortOrder
    severity?: SortOrder
    message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    resolved?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Alert"> | number
    device_id?: IntWithAggregatesFilter<"Alert"> | number
    alert_type?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityWithAggregatesFilter<"Alert"> | $Enums.AlertSeverity
    message?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    resolved?: BoolWithAggregatesFilter<"Alert"> | boolean
  }

  export type AdminCreateInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    commands?: CommandCreateNestedManyWithoutAdminInput
    logs?: LogCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutAdminInput
    logs?: LogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutAdminNestedInput
    logs?: LogUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutAdminNestedInput
    logs?: LogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
  }

  export type DeviceUpdateManyMutationInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
  }

  export type DeviceLocationCreateInput = {
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
    device: DeviceCreateNestedOneWithoutLocationsInput
  }

  export type DeviceLocationUncheckedCreateInput = {
    id?: number
    device_id: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
  }

  export type DeviceLocationUpdateInput = {
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type DeviceLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceLocationCreateManyInput = {
    id?: number
    device_id: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
  }

  export type DeviceLocationUpdateManyMutationInput = {
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateInput = {
    name: string
    description?: string | null
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: Date | string
    devicePolicies?: DevicePolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: Date | string
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    devicePolicies?: DevicePolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyCreateInput = {
    applied_at?: Date | string
    device: DeviceCreateNestedOneWithoutDevicePoliciesInput
    policy: PolicyCreateNestedOneWithoutDevicePoliciesInput
  }

  export type DevicePolicyUncheckedCreateInput = {
    id?: number
    device_id: number
    policy_id: number
    applied_at?: Date | string
  }

  export type DevicePolicyUpdateInput = {
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutDevicePoliciesNestedInput
    policy?: PolicyUpdateOneRequiredWithoutDevicePoliciesNestedInput
  }

  export type DevicePolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyCreateManyInput = {
    id?: number
    device_id: number
    policy_id: number
    applied_at?: Date | string
  }

  export type DevicePolicyUpdateManyMutationInput = {
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandCreateInput = {
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
    device: DeviceCreateNestedOneWithoutCommandsInput
    admin: AdminCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateInput = {
    id?: number
    device_id: number
    admin_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type CommandUpdateInput = {
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    device?: DeviceUpdateOneRequiredWithoutCommandsNestedInput
    admin?: AdminUpdateOneRequiredWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommandCreateManyInput = {
    id?: number
    device_id: number
    admin_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type CommandUpdateManyMutationInput = {
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateInput = {
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
    device?: DeviceCreateNestedOneWithoutLogsInput
    admin?: AdminCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    device_id?: number | null
    admin_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type LogUpdateInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutLogsNestedInput
    admin?: AdminUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: number
    device_id?: number | null
    admin_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppCreateInput = {
    name: string
    package_name: string
    version?: string | null
    source?: $Enums.AppSource
    download_url?: string | null
    created_at?: Date | string
    deviceApps?: DeviceAppCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateInput = {
    id?: number
    name: string
    package_name: string
    version?: string | null
    source?: $Enums.AppSource
    download_url?: string | null
    created_at?: Date | string
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceApps?: DeviceAppUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateManyInput = {
    id?: number
    name: string
    package_name: string
    version?: string | null
    source?: $Enums.AppSource
    download_url?: string | null
    created_at?: Date | string
  }

  export type AppUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceAppCreateInput = {
    status?: $Enums.DeviceAppStatus
    device: DeviceCreateNestedOneWithoutDeviceAppsInput
    app: AppCreateNestedOneWithoutDeviceAppsInput
  }

  export type DeviceAppUncheckedCreateInput = {
    id?: number
    device_id: number
    app_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceAppUpdateInput = {
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
    device?: DeviceUpdateOneRequiredWithoutDeviceAppsNestedInput
    app?: AppUpdateOneRequiredWithoutDeviceAppsNestedInput
  }

  export type DeviceAppUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    app_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceAppCreateManyInput = {
    id?: number
    device_id: number
    app_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceAppUpdateManyMutationInput = {
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceAppUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    app_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type GroupCreateInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    deviceGroups?: DeviceGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceGroups?: DeviceGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceGroupCreateInput = {
    device: DeviceCreateNestedOneWithoutDeviceGroupsInput
    group: GroupCreateNestedOneWithoutDeviceGroupsInput
  }

  export type DeviceGroupUncheckedCreateInput = {
    id?: number
    device_id: number
    group_id: number
  }

  export type DeviceGroupUpdateInput = {
    device?: DeviceUpdateOneRequiredWithoutDeviceGroupsNestedInput
    group?: GroupUpdateOneRequiredWithoutDeviceGroupsNestedInput
  }

  export type DeviceGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupCreateManyInput = {
    id?: number
    device_id: number
    group_id: number
  }

  export type DeviceGroupUpdateManyMutationInput = {

  }

  export type DeviceGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type AlertCreateInput = {
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
    device: DeviceCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: number
    device_id: number
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
  }

  export type AlertUpdateInput = {
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    device?: DeviceUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertCreateManyInput = {
    id?: number
    device_id: number
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
  }

  export type AlertUpdateManyMutationInput = {
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type CommandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[]
    notIn?: $Enums.DeviceStatus[]
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type DeviceLocationListRelationFilter = {
    every?: DeviceLocationWhereInput
    some?: DeviceLocationWhereInput
    none?: DeviceLocationWhereInput
  }

  export type DevicePolicyListRelationFilter = {
    every?: DevicePolicyWhereInput
    some?: DevicePolicyWhereInput
    none?: DevicePolicyWhereInput
  }

  export type DeviceAppListRelationFilter = {
    every?: DeviceAppWhereInput
    some?: DeviceAppWhereInput
    none?: DeviceAppWhereInput
  }

  export type DeviceGroupListRelationFilter = {
    every?: DeviceGroupWhereInput
    some?: DeviceGroupWhereInput
    none?: DeviceGroupWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DeviceLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DevicePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceAppOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelevanceInput = {
    fields: DeviceOrderByRelevanceFieldEnum | DeviceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    brand?: SortOrder
    os_version?: SortOrder
    enrolled_at?: SortOrder
    last_seen?: SortOrder
    battery_level?: SortOrder
    network_status?: SortOrder
    status?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    id?: SortOrder
    battery_level?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    brand?: SortOrder
    os_version?: SortOrder
    enrolled_at?: SortOrder
    last_seen?: SortOrder
    battery_level?: SortOrder
    network_status?: SortOrder
    status?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    brand?: SortOrder
    os_version?: SortOrder
    enrolled_at?: SortOrder
    last_seen?: SortOrder
    battery_level?: SortOrder
    network_status?: SortOrder
    status?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    id?: SortOrder
    battery_level?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[]
    notIn?: $Enums.DeviceStatus[]
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DeviceScalarRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type DeviceLocationCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    recorded_at?: SortOrder
  }

  export type DeviceLocationAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DeviceLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    recorded_at?: SortOrder
  }

  export type DeviceLocationMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    recorded_at?: SortOrder
  }

  export type DeviceLocationSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PolicyOrderByRelevanceInput = {
    fields: PolicyOrderByRelevanceFieldEnum | PolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allow_camera?: SortOrder
    allow_wifi?: SortOrder
    allow_bluetooth?: SortOrder
    require_password?: SortOrder
    kiosk_mode?: SortOrder
    created_at?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allow_camera?: SortOrder
    allow_wifi?: SortOrder
    allow_bluetooth?: SortOrder
    require_password?: SortOrder
    kiosk_mode?: SortOrder
    created_at?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allow_camera?: SortOrder
    allow_wifi?: SortOrder
    allow_bluetooth?: SortOrder
    require_password?: SortOrder
    kiosk_mode?: SortOrder
    created_at?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PolicyScalarRelationFilter = {
    is?: PolicyWhereInput
    isNot?: PolicyWhereInput
  }

  export type DevicePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
    applied_at?: SortOrder
  }

  export type DevicePolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
  }

  export type DevicePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
    applied_at?: SortOrder
  }

  export type DevicePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
    applied_at?: SortOrder
  }

  export type DevicePolicySumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    policy_id?: SortOrder
  }

  export type EnumCommandTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[]
    notIn?: $Enums.CommandType[]
    not?: NestedEnumCommandTypeFilter<$PrismaModel> | $Enums.CommandType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCommandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[]
    notIn?: $Enums.CommandStatus[]
    not?: NestedEnumCommandStatusFilter<$PrismaModel> | $Enums.CommandStatus
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type CommandCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    command_type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    executed_at?: SortOrder
  }

  export type CommandAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
  }

  export type CommandMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    command_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    executed_at?: SortOrder
  }

  export type CommandMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    command_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    executed_at?: SortOrder
  }

  export type CommandSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
  }

  export type EnumCommandTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[]
    notIn?: $Enums.CommandType[]
    not?: NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommandType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandTypeFilter<$PrismaModel>
    _max?: NestedEnumCommandTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCommandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[]
    notIn?: $Enums.CommandStatus[]
    not?: NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandStatusFilter<$PrismaModel>
    _max?: NestedEnumCommandStatusFilter<$PrismaModel>
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type LogOrderByRelevanceInput = {
    fields: LogOrderByRelevanceFieldEnum | LogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    event_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    event_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
    event_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    admin_id?: SortOrder
  }

  export type EnumAppSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSource | EnumAppSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AppSource[]
    notIn?: $Enums.AppSource[]
    not?: NestedEnumAppSourceFilter<$PrismaModel> | $Enums.AppSource
  }

  export type AppOrderByRelevanceInput = {
    fields: AppOrderByRelevanceFieldEnum | AppOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    package_name?: SortOrder
    version?: SortOrder
    source?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type AppAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AppMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    package_name?: SortOrder
    version?: SortOrder
    source?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type AppMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    package_name?: SortOrder
    version?: SortOrder
    source?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type AppSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAppSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSource | EnumAppSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AppSource[]
    notIn?: $Enums.AppSource[]
    not?: NestedEnumAppSourceWithAggregatesFilter<$PrismaModel> | $Enums.AppSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppSourceFilter<$PrismaModel>
    _max?: NestedEnumAppSourceFilter<$PrismaModel>
  }

  export type EnumDeviceAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceAppStatus | EnumDeviceAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceAppStatus[]
    notIn?: $Enums.DeviceAppStatus[]
    not?: NestedEnumDeviceAppStatusFilter<$PrismaModel> | $Enums.DeviceAppStatus
  }

  export type AppScalarRelationFilter = {
    is?: AppWhereInput
    isNot?: AppWhereInput
  }

  export type DeviceAppCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
    status?: SortOrder
  }

  export type DeviceAppAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
  }

  export type DeviceAppMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
    status?: SortOrder
  }

  export type DeviceAppMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
    status?: SortOrder
  }

  export type DeviceAppSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    app_id?: SortOrder
  }

  export type EnumDeviceAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceAppStatus | EnumDeviceAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceAppStatus[]
    notIn?: $Enums.DeviceAppStatus[]
    not?: NestedEnumDeviceAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceAppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceAppStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceAppStatusFilter<$PrismaModel>
  }

  export type GroupOrderByRelevanceInput = {
    fields: GroupOrderByRelevanceFieldEnum | GroupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type DeviceGroupCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
  }

  export type DeviceGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
  }

  export type DeviceGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
  }

  export type DeviceGroupMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
  }

  export type DeviceGroupSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    group_id?: SortOrder
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[]
    notIn?: $Enums.AlertType[]
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type AlertOrderByRelevanceInput = {
    fields: AlertOrderByRelevanceFieldEnum | AlertOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    alert_type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    resolved?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    alert_type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    resolved?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    alert_type?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    resolved?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[]
    notIn?: $Enums.AlertType[]
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type CommandCreateNestedManyWithoutAdminInput = {
    create?: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput> | CommandCreateWithoutAdminInput[] | CommandUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutAdminInput | CommandCreateOrConnectWithoutAdminInput[]
    createMany?: CommandCreateManyAdminInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutAdminInput = {
    create?: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput> | LogCreateWithoutAdminInput[] | LogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LogCreateOrConnectWithoutAdminInput | LogCreateOrConnectWithoutAdminInput[]
    createMany?: LogCreateManyAdminInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput> | CommandCreateWithoutAdminInput[] | CommandUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutAdminInput | CommandCreateOrConnectWithoutAdminInput[]
    createMany?: CommandCreateManyAdminInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput> | LogCreateWithoutAdminInput[] | LogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LogCreateOrConnectWithoutAdminInput | LogCreateOrConnectWithoutAdminInput[]
    createMany?: LogCreateManyAdminInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommandUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput> | CommandCreateWithoutAdminInput[] | CommandUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutAdminInput | CommandCreateOrConnectWithoutAdminInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutAdminInput | CommandUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CommandCreateManyAdminInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutAdminInput | CommandUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutAdminInput | CommandUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type LogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput> | LogCreateWithoutAdminInput[] | LogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LogCreateOrConnectWithoutAdminInput | LogCreateOrConnectWithoutAdminInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutAdminInput | LogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: LogCreateManyAdminInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutAdminInput | LogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: LogUpdateManyWithWhereWithoutAdminInput | LogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommandUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput> | CommandCreateWithoutAdminInput[] | CommandUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutAdminInput | CommandCreateOrConnectWithoutAdminInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutAdminInput | CommandUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CommandCreateManyAdminInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutAdminInput | CommandUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutAdminInput | CommandUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput> | LogCreateWithoutAdminInput[] | LogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LogCreateOrConnectWithoutAdminInput | LogCreateOrConnectWithoutAdminInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutAdminInput | LogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: LogCreateManyAdminInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutAdminInput | LogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: LogUpdateManyWithWhereWithoutAdminInput | LogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type DeviceLocationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput> | DeviceLocationCreateWithoutDeviceInput[] | DeviceLocationUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceLocationCreateOrConnectWithoutDeviceInput | DeviceLocationCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceLocationCreateManyDeviceInputEnvelope
    connect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
  }

  export type DevicePolicyCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput> | DevicePolicyCreateWithoutDeviceInput[] | DevicePolicyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutDeviceInput | DevicePolicyCreateOrConnectWithoutDeviceInput[]
    createMany?: DevicePolicyCreateManyDeviceInputEnvelope
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
  }

  export type CommandCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type DeviceAppCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput> | DeviceAppCreateWithoutDeviceInput[] | DeviceAppUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutDeviceInput | DeviceAppCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceAppCreateManyDeviceInputEnvelope
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
  }

  export type DeviceGroupCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput> | DeviceGroupCreateWithoutDeviceInput[] | DeviceGroupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutDeviceInput | DeviceGroupCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceGroupCreateManyDeviceInputEnvelope
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput> | AlertCreateWithoutDeviceInput[] | AlertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutDeviceInput | AlertCreateOrConnectWithoutDeviceInput[]
    createMany?: AlertCreateManyDeviceInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput> | DeviceLocationCreateWithoutDeviceInput[] | DeviceLocationUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceLocationCreateOrConnectWithoutDeviceInput | DeviceLocationCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceLocationCreateManyDeviceInputEnvelope
    connect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
  }

  export type DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput> | DevicePolicyCreateWithoutDeviceInput[] | DevicePolicyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutDeviceInput | DevicePolicyCreateOrConnectWithoutDeviceInput[]
    createMany?: DevicePolicyCreateManyDeviceInputEnvelope
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type DeviceAppUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput> | DeviceAppCreateWithoutDeviceInput[] | DeviceAppUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutDeviceInput | DeviceAppCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceAppCreateManyDeviceInputEnvelope
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
  }

  export type DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput> | DeviceGroupCreateWithoutDeviceInput[] | DeviceGroupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutDeviceInput | DeviceGroupCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceGroupCreateManyDeviceInputEnvelope
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput> | AlertCreateWithoutDeviceInput[] | AlertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutDeviceInput | AlertCreateOrConnectWithoutDeviceInput[]
    createMany?: AlertCreateManyDeviceInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceStatus
  }

  export type DeviceLocationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput> | DeviceLocationCreateWithoutDeviceInput[] | DeviceLocationUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceLocationCreateOrConnectWithoutDeviceInput | DeviceLocationCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceLocationUpsertWithWhereUniqueWithoutDeviceInput | DeviceLocationUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceLocationCreateManyDeviceInputEnvelope
    set?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    disconnect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    delete?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    connect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    update?: DeviceLocationUpdateWithWhereUniqueWithoutDeviceInput | DeviceLocationUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceLocationUpdateManyWithWhereWithoutDeviceInput | DeviceLocationUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceLocationScalarWhereInput | DeviceLocationScalarWhereInput[]
  }

  export type DevicePolicyUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput> | DevicePolicyCreateWithoutDeviceInput[] | DevicePolicyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutDeviceInput | DevicePolicyCreateOrConnectWithoutDeviceInput[]
    upsert?: DevicePolicyUpsertWithWhereUniqueWithoutDeviceInput | DevicePolicyUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DevicePolicyCreateManyDeviceInputEnvelope
    set?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    disconnect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    delete?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    update?: DevicePolicyUpdateWithWhereUniqueWithoutDeviceInput | DevicePolicyUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DevicePolicyUpdateManyWithWhereWithoutDeviceInput | DevicePolicyUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
  }

  export type CommandUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutDeviceInput | CommandUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutDeviceInput | CommandUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutDeviceInput | CommandUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type DeviceAppUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput> | DeviceAppCreateWithoutDeviceInput[] | DeviceAppUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutDeviceInput | DeviceAppCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceAppUpsertWithWhereUniqueWithoutDeviceInput | DeviceAppUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceAppCreateManyDeviceInputEnvelope
    set?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    disconnect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    delete?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    update?: DeviceAppUpdateWithWhereUniqueWithoutDeviceInput | DeviceAppUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceAppUpdateManyWithWhereWithoutDeviceInput | DeviceAppUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
  }

  export type DeviceGroupUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput> | DeviceGroupCreateWithoutDeviceInput[] | DeviceGroupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutDeviceInput | DeviceGroupCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceGroupUpsertWithWhereUniqueWithoutDeviceInput | DeviceGroupUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceGroupCreateManyDeviceInputEnvelope
    set?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    update?: DeviceGroupUpdateWithWhereUniqueWithoutDeviceInput | DeviceGroupUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceGroupUpdateManyWithWhereWithoutDeviceInput | DeviceGroupUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput> | AlertCreateWithoutDeviceInput[] | AlertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutDeviceInput | AlertCreateOrConnectWithoutDeviceInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutDeviceInput | AlertUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AlertCreateManyDeviceInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutDeviceInput | AlertUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutDeviceInput | AlertUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type LogUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutDeviceInput | LogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutDeviceInput | LogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LogUpdateManyWithWhereWithoutDeviceInput | LogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput> | DeviceLocationCreateWithoutDeviceInput[] | DeviceLocationUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceLocationCreateOrConnectWithoutDeviceInput | DeviceLocationCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceLocationUpsertWithWhereUniqueWithoutDeviceInput | DeviceLocationUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceLocationCreateManyDeviceInputEnvelope
    set?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    disconnect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    delete?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    connect?: DeviceLocationWhereUniqueInput | DeviceLocationWhereUniqueInput[]
    update?: DeviceLocationUpdateWithWhereUniqueWithoutDeviceInput | DeviceLocationUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceLocationUpdateManyWithWhereWithoutDeviceInput | DeviceLocationUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceLocationScalarWhereInput | DeviceLocationScalarWhereInput[]
  }

  export type DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput> | DevicePolicyCreateWithoutDeviceInput[] | DevicePolicyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutDeviceInput | DevicePolicyCreateOrConnectWithoutDeviceInput[]
    upsert?: DevicePolicyUpsertWithWhereUniqueWithoutDeviceInput | DevicePolicyUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DevicePolicyCreateManyDeviceInputEnvelope
    set?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    disconnect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    delete?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    update?: DevicePolicyUpdateWithWhereUniqueWithoutDeviceInput | DevicePolicyUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DevicePolicyUpdateManyWithWhereWithoutDeviceInput | DevicePolicyUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
  }

  export type CommandUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutDeviceInput | CommandUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutDeviceInput | CommandUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutDeviceInput | CommandUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput> | DeviceAppCreateWithoutDeviceInput[] | DeviceAppUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutDeviceInput | DeviceAppCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceAppUpsertWithWhereUniqueWithoutDeviceInput | DeviceAppUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceAppCreateManyDeviceInputEnvelope
    set?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    disconnect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    delete?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    update?: DeviceAppUpdateWithWhereUniqueWithoutDeviceInput | DeviceAppUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceAppUpdateManyWithWhereWithoutDeviceInput | DeviceAppUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
  }

  export type DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput> | DeviceGroupCreateWithoutDeviceInput[] | DeviceGroupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutDeviceInput | DeviceGroupCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceGroupUpsertWithWhereUniqueWithoutDeviceInput | DeviceGroupUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceGroupCreateManyDeviceInputEnvelope
    set?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    update?: DeviceGroupUpdateWithWhereUniqueWithoutDeviceInput | DeviceGroupUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceGroupUpdateManyWithWhereWithoutDeviceInput | DeviceGroupUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput> | AlertCreateWithoutDeviceInput[] | AlertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutDeviceInput | AlertCreateOrConnectWithoutDeviceInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutDeviceInput | AlertUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AlertCreateManyDeviceInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutDeviceInput | AlertUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutDeviceInput | AlertUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutDeviceInput | LogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutDeviceInput | LogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LogUpdateManyWithWhereWithoutDeviceInput | LogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutLocationsInput = {
    create?: XOR<DeviceCreateWithoutLocationsInput, DeviceUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLocationsInput
    connect?: DeviceWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DeviceUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<DeviceCreateWithoutLocationsInput, DeviceUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLocationsInput
    upsert?: DeviceUpsertWithoutLocationsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutLocationsInput, DeviceUpdateWithoutLocationsInput>, DeviceUncheckedUpdateWithoutLocationsInput>
  }

  export type DevicePolicyCreateNestedManyWithoutPolicyInput = {
    create?: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput> | DevicePolicyCreateWithoutPolicyInput[] | DevicePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutPolicyInput | DevicePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: DevicePolicyCreateManyPolicyInputEnvelope
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
  }

  export type DevicePolicyUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput> | DevicePolicyCreateWithoutPolicyInput[] | DevicePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutPolicyInput | DevicePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: DevicePolicyCreateManyPolicyInputEnvelope
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DevicePolicyUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput> | DevicePolicyCreateWithoutPolicyInput[] | DevicePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutPolicyInput | DevicePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: DevicePolicyUpsertWithWhereUniqueWithoutPolicyInput | DevicePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: DevicePolicyCreateManyPolicyInputEnvelope
    set?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    disconnect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    delete?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    update?: DevicePolicyUpdateWithWhereUniqueWithoutPolicyInput | DevicePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: DevicePolicyUpdateManyWithWhereWithoutPolicyInput | DevicePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
  }

  export type DevicePolicyUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput> | DevicePolicyCreateWithoutPolicyInput[] | DevicePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: DevicePolicyCreateOrConnectWithoutPolicyInput | DevicePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: DevicePolicyUpsertWithWhereUniqueWithoutPolicyInput | DevicePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: DevicePolicyCreateManyPolicyInputEnvelope
    set?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    disconnect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    delete?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    connect?: DevicePolicyWhereUniqueInput | DevicePolicyWhereUniqueInput[]
    update?: DevicePolicyUpdateWithWhereUniqueWithoutPolicyInput | DevicePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: DevicePolicyUpdateManyWithWhereWithoutPolicyInput | DevicePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutDevicePoliciesInput = {
    create?: XOR<DeviceCreateWithoutDevicePoliciesInput, DeviceUncheckedCreateWithoutDevicePoliciesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevicePoliciesInput
    connect?: DeviceWhereUniqueInput
  }

  export type PolicyCreateNestedOneWithoutDevicePoliciesInput = {
    create?: XOR<PolicyCreateWithoutDevicePoliciesInput, PolicyUncheckedCreateWithoutDevicePoliciesInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutDevicePoliciesInput
    connect?: PolicyWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDevicePoliciesNestedInput = {
    create?: XOR<DeviceCreateWithoutDevicePoliciesInput, DeviceUncheckedCreateWithoutDevicePoliciesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevicePoliciesInput
    upsert?: DeviceUpsertWithoutDevicePoliciesInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDevicePoliciesInput, DeviceUpdateWithoutDevicePoliciesInput>, DeviceUncheckedUpdateWithoutDevicePoliciesInput>
  }

  export type PolicyUpdateOneRequiredWithoutDevicePoliciesNestedInput = {
    create?: XOR<PolicyCreateWithoutDevicePoliciesInput, PolicyUncheckedCreateWithoutDevicePoliciesInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutDevicePoliciesInput
    upsert?: PolicyUpsertWithoutDevicePoliciesInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<XOR<PolicyUpdateToOneWithWhereWithoutDevicePoliciesInput, PolicyUpdateWithoutDevicePoliciesInput>, PolicyUncheckedUpdateWithoutDevicePoliciesInput>
  }

  export type DeviceCreateNestedOneWithoutCommandsInput = {
    create?: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCommandsInput
    connect?: DeviceWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutCommandsInput = {
    create?: XOR<AdminCreateWithoutCommandsInput, AdminUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCommandsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumCommandTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommandType
  }

  export type EnumCommandStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommandStatus
  }

  export type DeviceUpdateOneRequiredWithoutCommandsNestedInput = {
    create?: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCommandsInput
    upsert?: DeviceUpsertWithoutCommandsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutCommandsInput, DeviceUpdateWithoutCommandsInput>, DeviceUncheckedUpdateWithoutCommandsInput>
  }

  export type AdminUpdateOneRequiredWithoutCommandsNestedInput = {
    create?: XOR<AdminCreateWithoutCommandsInput, AdminUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCommandsInput
    upsert?: AdminUpsertWithoutCommandsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCommandsInput, AdminUpdateWithoutCommandsInput>, AdminUncheckedUpdateWithoutCommandsInput>
  }

  export type DeviceCreateNestedOneWithoutLogsInput = {
    create?: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLogsInput
    connect?: DeviceWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutLogsInput = {
    create?: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type DeviceUpdateOneWithoutLogsNestedInput = {
    create?: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLogsInput
    upsert?: DeviceUpsertWithoutLogsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutLogsInput, DeviceUpdateWithoutLogsInput>, DeviceUncheckedUpdateWithoutLogsInput>
  }

  export type AdminUpdateOneWithoutLogsNestedInput = {
    create?: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLogsInput
    upsert?: AdminUpsertWithoutLogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutLogsInput, AdminUpdateWithoutLogsInput>, AdminUncheckedUpdateWithoutLogsInput>
  }

  export type DeviceAppCreateNestedManyWithoutAppInput = {
    create?: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput> | DeviceAppCreateWithoutAppInput[] | DeviceAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutAppInput | DeviceAppCreateOrConnectWithoutAppInput[]
    createMany?: DeviceAppCreateManyAppInputEnvelope
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
  }

  export type DeviceAppUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput> | DeviceAppCreateWithoutAppInput[] | DeviceAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutAppInput | DeviceAppCreateOrConnectWithoutAppInput[]
    createMany?: DeviceAppCreateManyAppInputEnvelope
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
  }

  export type EnumAppSourceFieldUpdateOperationsInput = {
    set?: $Enums.AppSource
  }

  export type DeviceAppUpdateManyWithoutAppNestedInput = {
    create?: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput> | DeviceAppCreateWithoutAppInput[] | DeviceAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutAppInput | DeviceAppCreateOrConnectWithoutAppInput[]
    upsert?: DeviceAppUpsertWithWhereUniqueWithoutAppInput | DeviceAppUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: DeviceAppCreateManyAppInputEnvelope
    set?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    disconnect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    delete?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    update?: DeviceAppUpdateWithWhereUniqueWithoutAppInput | DeviceAppUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: DeviceAppUpdateManyWithWhereWithoutAppInput | DeviceAppUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
  }

  export type DeviceAppUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput> | DeviceAppCreateWithoutAppInput[] | DeviceAppUncheckedCreateWithoutAppInput[]
    connectOrCreate?: DeviceAppCreateOrConnectWithoutAppInput | DeviceAppCreateOrConnectWithoutAppInput[]
    upsert?: DeviceAppUpsertWithWhereUniqueWithoutAppInput | DeviceAppUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: DeviceAppCreateManyAppInputEnvelope
    set?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    disconnect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    delete?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    connect?: DeviceAppWhereUniqueInput | DeviceAppWhereUniqueInput[]
    update?: DeviceAppUpdateWithWhereUniqueWithoutAppInput | DeviceAppUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: DeviceAppUpdateManyWithWhereWithoutAppInput | DeviceAppUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutDeviceAppsInput = {
    create?: XOR<DeviceCreateWithoutDeviceAppsInput, DeviceUncheckedCreateWithoutDeviceAppsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceAppsInput
    connect?: DeviceWhereUniqueInput
  }

  export type AppCreateNestedOneWithoutDeviceAppsInput = {
    create?: XOR<AppCreateWithoutDeviceAppsInput, AppUncheckedCreateWithoutDeviceAppsInput>
    connectOrCreate?: AppCreateOrConnectWithoutDeviceAppsInput
    connect?: AppWhereUniqueInput
  }

  export type EnumDeviceAppStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceAppStatus
  }

  export type DeviceUpdateOneRequiredWithoutDeviceAppsNestedInput = {
    create?: XOR<DeviceCreateWithoutDeviceAppsInput, DeviceUncheckedCreateWithoutDeviceAppsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceAppsInput
    upsert?: DeviceUpsertWithoutDeviceAppsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDeviceAppsInput, DeviceUpdateWithoutDeviceAppsInput>, DeviceUncheckedUpdateWithoutDeviceAppsInput>
  }

  export type AppUpdateOneRequiredWithoutDeviceAppsNestedInput = {
    create?: XOR<AppCreateWithoutDeviceAppsInput, AppUncheckedCreateWithoutDeviceAppsInput>
    connectOrCreate?: AppCreateOrConnectWithoutDeviceAppsInput
    upsert?: AppUpsertWithoutDeviceAppsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutDeviceAppsInput, AppUpdateWithoutDeviceAppsInput>, AppUncheckedUpdateWithoutDeviceAppsInput>
  }

  export type DeviceGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput> | DeviceGroupCreateWithoutGroupInput[] | DeviceGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutGroupInput | DeviceGroupCreateOrConnectWithoutGroupInput[]
    createMany?: DeviceGroupCreateManyGroupInputEnvelope
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput> | DeviceGroupCreateWithoutGroupInput[] | DeviceGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutGroupInput | DeviceGroupCreateOrConnectWithoutGroupInput[]
    createMany?: DeviceGroupCreateManyGroupInputEnvelope
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput> | DeviceGroupCreateWithoutGroupInput[] | DeviceGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutGroupInput | DeviceGroupCreateOrConnectWithoutGroupInput[]
    upsert?: DeviceGroupUpsertWithWhereUniqueWithoutGroupInput | DeviceGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: DeviceGroupCreateManyGroupInputEnvelope
    set?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    update?: DeviceGroupUpdateWithWhereUniqueWithoutGroupInput | DeviceGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: DeviceGroupUpdateManyWithWhereWithoutGroupInput | DeviceGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
  }

  export type DeviceGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput> | DeviceGroupCreateWithoutGroupInput[] | DeviceGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: DeviceGroupCreateOrConnectWithoutGroupInput | DeviceGroupCreateOrConnectWithoutGroupInput[]
    upsert?: DeviceGroupUpsertWithWhereUniqueWithoutGroupInput | DeviceGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: DeviceGroupCreateManyGroupInputEnvelope
    set?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupWhereUniqueInput | DeviceGroupWhereUniqueInput[]
    update?: DeviceGroupUpdateWithWhereUniqueWithoutGroupInput | DeviceGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: DeviceGroupUpdateManyWithWhereWithoutGroupInput | DeviceGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutDeviceGroupsInput = {
    create?: XOR<DeviceCreateWithoutDeviceGroupsInput, DeviceUncheckedCreateWithoutDeviceGroupsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceGroupsInput
    connect?: DeviceWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutDeviceGroupsInput = {
    create?: XOR<GroupCreateWithoutDeviceGroupsInput, GroupUncheckedCreateWithoutDeviceGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutDeviceGroupsInput
    connect?: GroupWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDeviceGroupsNestedInput = {
    create?: XOR<DeviceCreateWithoutDeviceGroupsInput, DeviceUncheckedCreateWithoutDeviceGroupsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceGroupsInput
    upsert?: DeviceUpsertWithoutDeviceGroupsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDeviceGroupsInput, DeviceUpdateWithoutDeviceGroupsInput>, DeviceUncheckedUpdateWithoutDeviceGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutDeviceGroupsNestedInput = {
    create?: XOR<GroupCreateWithoutDeviceGroupsInput, GroupUncheckedCreateWithoutDeviceGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutDeviceGroupsInput
    upsert?: GroupUpsertWithoutDeviceGroupsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutDeviceGroupsInput, GroupUpdateWithoutDeviceGroupsInput>, GroupUncheckedUpdateWithoutDeviceGroupsInput>
  }

  export type DeviceCreateNestedOneWithoutAlertsInput = {
    create?: XOR<DeviceCreateWithoutAlertsInput, DeviceUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAlertsInput
    connect?: DeviceWhereUniqueInput
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumAlertSeverityFieldUpdateOperationsInput = {
    set?: $Enums.AlertSeverity
  }

  export type DeviceUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<DeviceCreateWithoutAlertsInput, DeviceUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAlertsInput
    upsert?: DeviceUpsertWithoutAlertsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutAlertsInput, DeviceUpdateWithoutAlertsInput>, DeviceUncheckedUpdateWithoutAlertsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[]
    notIn?: $Enums.DeviceStatus[]
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[]
    notIn?: $Enums.DeviceStatus[]
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCommandTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[]
    notIn?: $Enums.CommandType[]
    not?: NestedEnumCommandTypeFilter<$PrismaModel> | $Enums.CommandType
  }

  export type NestedEnumCommandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[]
    notIn?: $Enums.CommandStatus[]
    not?: NestedEnumCommandStatusFilter<$PrismaModel> | $Enums.CommandStatus
  }

  export type NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[]
    notIn?: $Enums.CommandType[]
    not?: NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommandType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandTypeFilter<$PrismaModel>
    _max?: NestedEnumCommandTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[]
    notIn?: $Enums.CommandStatus[]
    not?: NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandStatusFilter<$PrismaModel>
    _max?: NestedEnumCommandStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSource | EnumAppSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AppSource[]
    notIn?: $Enums.AppSource[]
    not?: NestedEnumAppSourceFilter<$PrismaModel> | $Enums.AppSource
  }

  export type NestedEnumAppSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSource | EnumAppSourceFieldRefInput<$PrismaModel>
    in?: $Enums.AppSource[]
    notIn?: $Enums.AppSource[]
    not?: NestedEnumAppSourceWithAggregatesFilter<$PrismaModel> | $Enums.AppSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppSourceFilter<$PrismaModel>
    _max?: NestedEnumAppSourceFilter<$PrismaModel>
  }

  export type NestedEnumDeviceAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceAppStatus | EnumDeviceAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceAppStatus[]
    notIn?: $Enums.DeviceAppStatus[]
    not?: NestedEnumDeviceAppStatusFilter<$PrismaModel> | $Enums.DeviceAppStatus
  }

  export type NestedEnumDeviceAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceAppStatus | EnumDeviceAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceAppStatus[]
    notIn?: $Enums.DeviceAppStatus[]
    not?: NestedEnumDeviceAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceAppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceAppStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceAppStatusFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[]
    notIn?: $Enums.AlertType[]
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[]
    notIn?: $Enums.AlertType[]
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type CommandCreateWithoutAdminInput = {
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
    device: DeviceCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutAdminInput = {
    id?: number
    device_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type CommandCreateOrConnectWithoutAdminInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput>
  }

  export type CommandCreateManyAdminInputEnvelope = {
    data: CommandCreateManyAdminInput | CommandCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutAdminInput = {
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
    device?: DeviceCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutAdminInput = {
    id?: number
    device_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type LogCreateOrConnectWithoutAdminInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput>
  }

  export type LogCreateManyAdminInputEnvelope = {
    data: LogCreateManyAdminInput | LogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type CommandUpsertWithWhereUniqueWithoutAdminInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutAdminInput, CommandUncheckedUpdateWithoutAdminInput>
    create: XOR<CommandCreateWithoutAdminInput, CommandUncheckedCreateWithoutAdminInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutAdminInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutAdminInput, CommandUncheckedUpdateWithoutAdminInput>
  }

  export type CommandUpdateManyWithWhereWithoutAdminInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutAdminInput>
  }

  export type CommandScalarWhereInput = {
    AND?: CommandScalarWhereInput | CommandScalarWhereInput[]
    OR?: CommandScalarWhereInput[]
    NOT?: CommandScalarWhereInput | CommandScalarWhereInput[]
    id?: IntFilter<"Command"> | number
    device_id?: IntFilter<"Command"> | number
    admin_id?: IntFilter<"Command"> | number
    command_type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonNullableFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    created_at?: DateTimeFilter<"Command"> | Date | string
    executed_at?: DateTimeNullableFilter<"Command"> | Date | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutAdminInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutAdminInput, LogUncheckedUpdateWithoutAdminInput>
    create: XOR<LogCreateWithoutAdminInput, LogUncheckedCreateWithoutAdminInput>
  }

  export type LogUpdateWithWhereUniqueWithoutAdminInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutAdminInput, LogUncheckedUpdateWithoutAdminInput>
  }

  export type LogUpdateManyWithWhereWithoutAdminInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutAdminInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    device_id?: IntNullableFilter<"Log"> | number | null
    admin_id?: IntNullableFilter<"Log"> | number | null
    event_type?: StringNullableFilter<"Log"> | string | null
    message?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
  }

  export type DeviceLocationCreateWithoutDeviceInput = {
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
  }

  export type DeviceLocationUncheckedCreateWithoutDeviceInput = {
    id?: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
  }

  export type DeviceLocationCreateOrConnectWithoutDeviceInput = {
    where: DeviceLocationWhereUniqueInput
    create: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceLocationCreateManyDeviceInputEnvelope = {
    data: DeviceLocationCreateManyDeviceInput | DeviceLocationCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DevicePolicyCreateWithoutDeviceInput = {
    applied_at?: Date | string
    policy: PolicyCreateNestedOneWithoutDevicePoliciesInput
  }

  export type DevicePolicyUncheckedCreateWithoutDeviceInput = {
    id?: number
    policy_id: number
    applied_at?: Date | string
  }

  export type DevicePolicyCreateOrConnectWithoutDeviceInput = {
    where: DevicePolicyWhereUniqueInput
    create: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput>
  }

  export type DevicePolicyCreateManyDeviceInputEnvelope = {
    data: DevicePolicyCreateManyDeviceInput | DevicePolicyCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type CommandCreateWithoutDeviceInput = {
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
    admin: AdminCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutDeviceInput = {
    id?: number
    admin_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type CommandCreateOrConnectWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput>
  }

  export type CommandCreateManyDeviceInputEnvelope = {
    data: CommandCreateManyDeviceInput | CommandCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceAppCreateWithoutDeviceInput = {
    status?: $Enums.DeviceAppStatus
    app: AppCreateNestedOneWithoutDeviceAppsInput
  }

  export type DeviceAppUncheckedCreateWithoutDeviceInput = {
    id?: number
    app_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceAppCreateOrConnectWithoutDeviceInput = {
    where: DeviceAppWhereUniqueInput
    create: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceAppCreateManyDeviceInputEnvelope = {
    data: DeviceAppCreateManyDeviceInput | DeviceAppCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceGroupCreateWithoutDeviceInput = {
    group: GroupCreateNestedOneWithoutDeviceGroupsInput
  }

  export type DeviceGroupUncheckedCreateWithoutDeviceInput = {
    id?: number
    group_id: number
  }

  export type DeviceGroupCreateOrConnectWithoutDeviceInput = {
    where: DeviceGroupWhereUniqueInput
    create: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceGroupCreateManyDeviceInputEnvelope = {
    data: DeviceGroupCreateManyDeviceInput | DeviceGroupCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutDeviceInput = {
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
  }

  export type AlertUncheckedCreateWithoutDeviceInput = {
    id?: number
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
  }

  export type AlertCreateOrConnectWithoutDeviceInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput>
  }

  export type AlertCreateManyDeviceInputEnvelope = {
    data: AlertCreateManyDeviceInput | AlertCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutDeviceInput = {
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
    admin?: AdminCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutDeviceInput = {
    id?: number
    admin_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type LogCreateOrConnectWithoutDeviceInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput>
  }

  export type LogCreateManyDeviceInputEnvelope = {
    data: LogCreateManyDeviceInput | LogCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceLocationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceLocationWhereUniqueInput
    update: XOR<DeviceLocationUpdateWithoutDeviceInput, DeviceLocationUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceLocationCreateWithoutDeviceInput, DeviceLocationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceLocationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceLocationWhereUniqueInput
    data: XOR<DeviceLocationUpdateWithoutDeviceInput, DeviceLocationUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceLocationUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceLocationScalarWhereInput
    data: XOR<DeviceLocationUpdateManyMutationInput, DeviceLocationUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceLocationScalarWhereInput = {
    AND?: DeviceLocationScalarWhereInput | DeviceLocationScalarWhereInput[]
    OR?: DeviceLocationScalarWhereInput[]
    NOT?: DeviceLocationScalarWhereInput | DeviceLocationScalarWhereInput[]
    id?: IntFilter<"DeviceLocation"> | number
    device_id?: IntFilter<"DeviceLocation"> | number
    latitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"DeviceLocation"> | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFilter<"DeviceLocation"> | Date | string
  }

  export type DevicePolicyUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DevicePolicyWhereUniqueInput
    update: XOR<DevicePolicyUpdateWithoutDeviceInput, DevicePolicyUncheckedUpdateWithoutDeviceInput>
    create: XOR<DevicePolicyCreateWithoutDeviceInput, DevicePolicyUncheckedCreateWithoutDeviceInput>
  }

  export type DevicePolicyUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DevicePolicyWhereUniqueInput
    data: XOR<DevicePolicyUpdateWithoutDeviceInput, DevicePolicyUncheckedUpdateWithoutDeviceInput>
  }

  export type DevicePolicyUpdateManyWithWhereWithoutDeviceInput = {
    where: DevicePolicyScalarWhereInput
    data: XOR<DevicePolicyUpdateManyMutationInput, DevicePolicyUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DevicePolicyScalarWhereInput = {
    AND?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
    OR?: DevicePolicyScalarWhereInput[]
    NOT?: DevicePolicyScalarWhereInput | DevicePolicyScalarWhereInput[]
    id?: IntFilter<"DevicePolicy"> | number
    device_id?: IntFilter<"DevicePolicy"> | number
    policy_id?: IntFilter<"DevicePolicy"> | number
    applied_at?: DateTimeFilter<"DevicePolicy"> | Date | string
  }

  export type CommandUpsertWithWhereUniqueWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutDeviceInput, CommandUncheckedUpdateWithoutDeviceInput>
    create: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutDeviceInput, CommandUncheckedUpdateWithoutDeviceInput>
  }

  export type CommandUpdateManyWithWhereWithoutDeviceInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceAppUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceAppWhereUniqueInput
    update: XOR<DeviceAppUpdateWithoutDeviceInput, DeviceAppUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceAppCreateWithoutDeviceInput, DeviceAppUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceAppUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceAppWhereUniqueInput
    data: XOR<DeviceAppUpdateWithoutDeviceInput, DeviceAppUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceAppUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceAppScalarWhereInput
    data: XOR<DeviceAppUpdateManyMutationInput, DeviceAppUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceAppScalarWhereInput = {
    AND?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
    OR?: DeviceAppScalarWhereInput[]
    NOT?: DeviceAppScalarWhereInput | DeviceAppScalarWhereInput[]
    id?: IntFilter<"DeviceApp"> | number
    device_id?: IntFilter<"DeviceApp"> | number
    app_id?: IntFilter<"DeviceApp"> | number
    status?: EnumDeviceAppStatusFilter<"DeviceApp"> | $Enums.DeviceAppStatus
  }

  export type DeviceGroupUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceGroupWhereUniqueInput
    update: XOR<DeviceGroupUpdateWithoutDeviceInput, DeviceGroupUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceGroupCreateWithoutDeviceInput, DeviceGroupUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceGroupUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceGroupWhereUniqueInput
    data: XOR<DeviceGroupUpdateWithoutDeviceInput, DeviceGroupUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceGroupUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceGroupScalarWhereInput
    data: XOR<DeviceGroupUpdateManyMutationInput, DeviceGroupUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceGroupScalarWhereInput = {
    AND?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
    OR?: DeviceGroupScalarWhereInput[]
    NOT?: DeviceGroupScalarWhereInput | DeviceGroupScalarWhereInput[]
    id?: IntFilter<"DeviceGroup"> | number
    device_id?: IntFilter<"DeviceGroup"> | number
    group_id?: IntFilter<"DeviceGroup"> | number
  }

  export type AlertUpsertWithWhereUniqueWithoutDeviceInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutDeviceInput, AlertUncheckedUpdateWithoutDeviceInput>
    create: XOR<AlertCreateWithoutDeviceInput, AlertUncheckedCreateWithoutDeviceInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutDeviceInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutDeviceInput, AlertUncheckedUpdateWithoutDeviceInput>
  }

  export type AlertUpdateManyWithWhereWithoutDeviceInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutDeviceInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: IntFilter<"Alert"> | number
    device_id?: IntFilter<"Alert"> | number
    alert_type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    message?: StringNullableFilter<"Alert"> | string | null
    created_at?: DateTimeFilter<"Alert"> | Date | string
    resolved?: BoolFilter<"Alert"> | boolean
  }

  export type LogUpsertWithWhereUniqueWithoutDeviceInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutDeviceInput, LogUncheckedUpdateWithoutDeviceInput>
    create: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput>
  }

  export type LogUpdateWithWhereUniqueWithoutDeviceInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutDeviceInput, LogUncheckedUpdateWithoutDeviceInput>
  }

  export type LogUpdateManyWithWhereWithoutDeviceInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceCreateWithoutLocationsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutLocationsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutLocationsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutLocationsInput, DeviceUncheckedCreateWithoutLocationsInput>
  }

  export type DeviceUpsertWithoutLocationsInput = {
    update: XOR<DeviceUpdateWithoutLocationsInput, DeviceUncheckedUpdateWithoutLocationsInput>
    create: XOR<DeviceCreateWithoutLocationsInput, DeviceUncheckedCreateWithoutLocationsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutLocationsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutLocationsInput, DeviceUncheckedUpdateWithoutLocationsInput>
  }

  export type DeviceUpdateWithoutLocationsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DevicePolicyCreateWithoutPolicyInput = {
    applied_at?: Date | string
    device: DeviceCreateNestedOneWithoutDevicePoliciesInput
  }

  export type DevicePolicyUncheckedCreateWithoutPolicyInput = {
    id?: number
    device_id: number
    applied_at?: Date | string
  }

  export type DevicePolicyCreateOrConnectWithoutPolicyInput = {
    where: DevicePolicyWhereUniqueInput
    create: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type DevicePolicyCreateManyPolicyInputEnvelope = {
    data: DevicePolicyCreateManyPolicyInput | DevicePolicyCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type DevicePolicyUpsertWithWhereUniqueWithoutPolicyInput = {
    where: DevicePolicyWhereUniqueInput
    update: XOR<DevicePolicyUpdateWithoutPolicyInput, DevicePolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<DevicePolicyCreateWithoutPolicyInput, DevicePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type DevicePolicyUpdateWithWhereUniqueWithoutPolicyInput = {
    where: DevicePolicyWhereUniqueInput
    data: XOR<DevicePolicyUpdateWithoutPolicyInput, DevicePolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type DevicePolicyUpdateManyWithWhereWithoutPolicyInput = {
    where: DevicePolicyScalarWhereInput
    data: XOR<DevicePolicyUpdateManyMutationInput, DevicePolicyUncheckedUpdateManyWithoutPolicyInput>
  }

  export type DeviceCreateWithoutDevicePoliciesInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDevicePoliciesInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDevicePoliciesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDevicePoliciesInput, DeviceUncheckedCreateWithoutDevicePoliciesInput>
  }

  export type PolicyCreateWithoutDevicePoliciesInput = {
    name: string
    description?: string | null
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: Date | string
  }

  export type PolicyUncheckedCreateWithoutDevicePoliciesInput = {
    id?: number
    name: string
    description?: string | null
    allow_camera?: boolean
    allow_wifi?: boolean
    allow_bluetooth?: boolean
    require_password?: boolean
    kiosk_mode?: boolean
    created_at?: Date | string
  }

  export type PolicyCreateOrConnectWithoutDevicePoliciesInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutDevicePoliciesInput, PolicyUncheckedCreateWithoutDevicePoliciesInput>
  }

  export type DeviceUpsertWithoutDevicePoliciesInput = {
    update: XOR<DeviceUpdateWithoutDevicePoliciesInput, DeviceUncheckedUpdateWithoutDevicePoliciesInput>
    create: XOR<DeviceCreateWithoutDevicePoliciesInput, DeviceUncheckedCreateWithoutDevicePoliciesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDevicePoliciesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDevicePoliciesInput, DeviceUncheckedUpdateWithoutDevicePoliciesInput>
  }

  export type DeviceUpdateWithoutDevicePoliciesInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDevicePoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type PolicyUpsertWithoutDevicePoliciesInput = {
    update: XOR<PolicyUpdateWithoutDevicePoliciesInput, PolicyUncheckedUpdateWithoutDevicePoliciesInput>
    create: XOR<PolicyCreateWithoutDevicePoliciesInput, PolicyUncheckedCreateWithoutDevicePoliciesInput>
    where?: PolicyWhereInput
  }

  export type PolicyUpdateToOneWithWhereWithoutDevicePoliciesInput = {
    where?: PolicyWhereInput
    data: XOR<PolicyUpdateWithoutDevicePoliciesInput, PolicyUncheckedUpdateWithoutDevicePoliciesInput>
  }

  export type PolicyUpdateWithoutDevicePoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateWithoutDevicePoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_camera?: BoolFieldUpdateOperationsInput | boolean
    allow_wifi?: BoolFieldUpdateOperationsInput | boolean
    allow_bluetooth?: BoolFieldUpdateOperationsInput | boolean
    require_password?: BoolFieldUpdateOperationsInput | boolean
    kiosk_mode?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateWithoutCommandsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutCommandsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutCommandsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
  }

  export type AdminCreateWithoutCommandsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    logs?: LogCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCommandsInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCommandsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCommandsInput, AdminUncheckedCreateWithoutCommandsInput>
  }

  export type DeviceUpsertWithoutCommandsInput = {
    update: XOR<DeviceUpdateWithoutCommandsInput, DeviceUncheckedUpdateWithoutCommandsInput>
    create: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutCommandsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutCommandsInput, DeviceUncheckedUpdateWithoutCommandsInput>
  }

  export type DeviceUpdateWithoutCommandsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutCommandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type AdminUpsertWithoutCommandsInput = {
    update: XOR<AdminUpdateWithoutCommandsInput, AdminUncheckedUpdateWithoutCommandsInput>
    create: XOR<AdminCreateWithoutCommandsInput, AdminUncheckedCreateWithoutCommandsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCommandsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCommandsInput, AdminUncheckedUpdateWithoutCommandsInput>
  }

  export type AdminUpdateWithoutCommandsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCommandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type DeviceCreateWithoutLogsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutLogsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutLogsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
  }

  export type AdminCreateWithoutLogsInput = {
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    commands?: CommandCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutLogsInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    role?: $Enums.Role
    created_at?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
  }

  export type DeviceUpsertWithoutLogsInput = {
    update: XOR<DeviceUpdateWithoutLogsInput, DeviceUncheckedUpdateWithoutLogsInput>
    create: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutLogsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutLogsInput, DeviceUncheckedUpdateWithoutLogsInput>
  }

  export type DeviceUpdateWithoutLogsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type AdminUpsertWithoutLogsInput = {
    update: XOR<AdminUpdateWithoutLogsInput, AdminUncheckedUpdateWithoutLogsInput>
    create: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutLogsInput, AdminUncheckedUpdateWithoutLogsInput>
  }

  export type AdminUpdateWithoutLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type DeviceAppCreateWithoutAppInput = {
    status?: $Enums.DeviceAppStatus
    device: DeviceCreateNestedOneWithoutDeviceAppsInput
  }

  export type DeviceAppUncheckedCreateWithoutAppInput = {
    id?: number
    device_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceAppCreateOrConnectWithoutAppInput = {
    where: DeviceAppWhereUniqueInput
    create: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput>
  }

  export type DeviceAppCreateManyAppInputEnvelope = {
    data: DeviceAppCreateManyAppInput | DeviceAppCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type DeviceAppUpsertWithWhereUniqueWithoutAppInput = {
    where: DeviceAppWhereUniqueInput
    update: XOR<DeviceAppUpdateWithoutAppInput, DeviceAppUncheckedUpdateWithoutAppInput>
    create: XOR<DeviceAppCreateWithoutAppInput, DeviceAppUncheckedCreateWithoutAppInput>
  }

  export type DeviceAppUpdateWithWhereUniqueWithoutAppInput = {
    where: DeviceAppWhereUniqueInput
    data: XOR<DeviceAppUpdateWithoutAppInput, DeviceAppUncheckedUpdateWithoutAppInput>
  }

  export type DeviceAppUpdateManyWithWhereWithoutAppInput = {
    where: DeviceAppScalarWhereInput
    data: XOR<DeviceAppUpdateManyMutationInput, DeviceAppUncheckedUpdateManyWithoutAppInput>
  }

  export type DeviceCreateWithoutDeviceAppsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDeviceAppsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDeviceAppsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDeviceAppsInput, DeviceUncheckedCreateWithoutDeviceAppsInput>
  }

  export type AppCreateWithoutDeviceAppsInput = {
    name: string
    package_name: string
    version?: string | null
    source?: $Enums.AppSource
    download_url?: string | null
    created_at?: Date | string
  }

  export type AppUncheckedCreateWithoutDeviceAppsInput = {
    id?: number
    name: string
    package_name: string
    version?: string | null
    source?: $Enums.AppSource
    download_url?: string | null
    created_at?: Date | string
  }

  export type AppCreateOrConnectWithoutDeviceAppsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutDeviceAppsInput, AppUncheckedCreateWithoutDeviceAppsInput>
  }

  export type DeviceUpsertWithoutDeviceAppsInput = {
    update: XOR<DeviceUpdateWithoutDeviceAppsInput, DeviceUncheckedUpdateWithoutDeviceAppsInput>
    create: XOR<DeviceCreateWithoutDeviceAppsInput, DeviceUncheckedCreateWithoutDeviceAppsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDeviceAppsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDeviceAppsInput, DeviceUncheckedUpdateWithoutDeviceAppsInput>
  }

  export type DeviceUpdateWithoutDeviceAppsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDeviceAppsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type AppUpsertWithoutDeviceAppsInput = {
    update: XOR<AppUpdateWithoutDeviceAppsInput, AppUncheckedUpdateWithoutDeviceAppsInput>
    create: XOR<AppCreateWithoutDeviceAppsInput, AppUncheckedCreateWithoutDeviceAppsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutDeviceAppsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutDeviceAppsInput, AppUncheckedUpdateWithoutDeviceAppsInput>
  }

  export type AppUpdateWithoutDeviceAppsInput = {
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppUncheckedUpdateWithoutDeviceAppsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    package_name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumAppSourceFieldUpdateOperationsInput | $Enums.AppSource
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceGroupCreateWithoutGroupInput = {
    device: DeviceCreateNestedOneWithoutDeviceGroupsInput
  }

  export type DeviceGroupUncheckedCreateWithoutGroupInput = {
    id?: number
    device_id: number
  }

  export type DeviceGroupCreateOrConnectWithoutGroupInput = {
    where: DeviceGroupWhereUniqueInput
    create: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput>
  }

  export type DeviceGroupCreateManyGroupInputEnvelope = {
    data: DeviceGroupCreateManyGroupInput | DeviceGroupCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type DeviceGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: DeviceGroupWhereUniqueInput
    update: XOR<DeviceGroupUpdateWithoutGroupInput, DeviceGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<DeviceGroupCreateWithoutGroupInput, DeviceGroupUncheckedCreateWithoutGroupInput>
  }

  export type DeviceGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: DeviceGroupWhereUniqueInput
    data: XOR<DeviceGroupUpdateWithoutGroupInput, DeviceGroupUncheckedUpdateWithoutGroupInput>
  }

  export type DeviceGroupUpdateManyWithWhereWithoutGroupInput = {
    where: DeviceGroupScalarWhereInput
    data: XOR<DeviceGroupUpdateManyMutationInput, DeviceGroupUncheckedUpdateManyWithoutGroupInput>
  }

  export type DeviceCreateWithoutDeviceGroupsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    alerts?: AlertCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDeviceGroupsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    alerts?: AlertUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDeviceGroupsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDeviceGroupsInput, DeviceUncheckedCreateWithoutDeviceGroupsInput>
  }

  export type GroupCreateWithoutDeviceGroupsInput = {
    name: string
    description?: string | null
    created_at?: Date | string
  }

  export type GroupUncheckedCreateWithoutDeviceGroupsInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
  }

  export type GroupCreateOrConnectWithoutDeviceGroupsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutDeviceGroupsInput, GroupUncheckedCreateWithoutDeviceGroupsInput>
  }

  export type DeviceUpsertWithoutDeviceGroupsInput = {
    update: XOR<DeviceUpdateWithoutDeviceGroupsInput, DeviceUncheckedUpdateWithoutDeviceGroupsInput>
    create: XOR<DeviceCreateWithoutDeviceGroupsInput, DeviceUncheckedCreateWithoutDeviceGroupsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDeviceGroupsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDeviceGroupsInput, DeviceUncheckedUpdateWithoutDeviceGroupsInput>
  }

  export type DeviceUpdateWithoutDeviceGroupsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDeviceGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type GroupUpsertWithoutDeviceGroupsInput = {
    update: XOR<GroupUpdateWithoutDeviceGroupsInput, GroupUncheckedUpdateWithoutDeviceGroupsInput>
    create: XOR<GroupCreateWithoutDeviceGroupsInput, GroupUncheckedCreateWithoutDeviceGroupsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutDeviceGroupsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutDeviceGroupsInput, GroupUncheckedUpdateWithoutDeviceGroupsInput>
  }

  export type GroupUpdateWithoutDeviceGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateWithoutDeviceGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateWithoutAlertsInput = {
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupCreateNestedManyWithoutDeviceInput
    logs?: LogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutAlertsInput = {
    id?: number
    device_id: string
    serial_number?: string | null
    model?: string | null
    brand?: string | null
    os_version?: string | null
    enrolled_at?: Date | string
    last_seen?: Date | string | null
    battery_level?: number | null
    network_status?: string | null
    status?: $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedCreateNestedManyWithoutDeviceInput
    devicePolicies?: DevicePolicyUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    deviceApps?: DeviceAppUncheckedCreateNestedManyWithoutDeviceInput
    deviceGroups?: DeviceGroupUncheckedCreateNestedManyWithoutDeviceInput
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutAlertsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutAlertsInput, DeviceUncheckedCreateWithoutAlertsInput>
  }

  export type DeviceUpsertWithoutAlertsInput = {
    update: XOR<DeviceUpdateWithoutAlertsInput, DeviceUncheckedUpdateWithoutAlertsInput>
    create: XOR<DeviceCreateWithoutAlertsInput, DeviceUncheckedCreateWithoutAlertsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutAlertsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutAlertsInput, DeviceUncheckedUpdateWithoutAlertsInput>
  }

  export type DeviceUpdateWithoutAlertsInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUpdateManyWithoutDeviceNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: StringFieldUpdateOperationsInput | string
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    os_version?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battery_level?: NullableIntFieldUpdateOperationsInput | number | null
    network_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    locations?: DeviceLocationUncheckedUpdateManyWithoutDeviceNestedInput
    devicePolicies?: DevicePolicyUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    deviceApps?: DeviceAppUncheckedUpdateManyWithoutDeviceNestedInput
    deviceGroups?: DeviceGroupUncheckedUpdateManyWithoutDeviceNestedInput
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type CommandCreateManyAdminInput = {
    id?: number
    device_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type LogCreateManyAdminInput = {
    id?: number
    device_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type CommandUpdateWithoutAdminInput = {
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    device?: DeviceUpdateOneRequiredWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommandUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUpdateWithoutAdminInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceLocationCreateManyDeviceInput = {
    id?: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    recorded_at?: Date | string
  }

  export type DevicePolicyCreateManyDeviceInput = {
    id?: number
    policy_id: number
    applied_at?: Date | string
  }

  export type CommandCreateManyDeviceInput = {
    id?: number
    admin_id: number
    command_type: $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    created_at?: Date | string
    executed_at?: Date | string | null
  }

  export type DeviceAppCreateManyDeviceInput = {
    id?: number
    app_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceGroupCreateManyDeviceInput = {
    id?: number
    group_id: number
  }

  export type AlertCreateManyDeviceInput = {
    id?: number
    alert_type: $Enums.AlertType
    severity?: $Enums.AlertSeverity
    message?: string | null
    created_at?: Date | string
    resolved?: boolean
  }

  export type LogCreateManyDeviceInput = {
    id?: number
    admin_id?: number | null
    event_type?: string | null
    message?: string | null
    created_at?: Date | string
  }

  export type DeviceLocationUpdateWithoutDeviceInput = {
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceLocationUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceLocationUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recorded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyUpdateWithoutDeviceInput = {
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyUpdateOneRequiredWithoutDevicePoliciesNestedInput
  }

  export type DevicePolicyUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandUpdateWithoutDeviceInput = {
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommandUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    command_type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceAppUpdateWithoutDeviceInput = {
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
    app?: AppUpdateOneRequiredWithoutDeviceAppsNestedInput
  }

  export type DeviceAppUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceAppUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceGroupUpdateWithoutDeviceInput = {
    group?: GroupUpdateOneRequiredWithoutDeviceGroupsNestedInput
  }

  export type DeviceGroupUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type AlertUpdateWithoutDeviceInput = {
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlertUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    alert_type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogUpdateWithoutDeviceInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyCreateManyPolicyInput = {
    id?: number
    device_id: number
    applied_at?: Date | string
  }

  export type DevicePolicyUpdateWithoutPolicyInput = {
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutDevicePoliciesNestedInput
  }

  export type DevicePolicyUncheckedUpdateWithoutPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevicePolicyUncheckedUpdateManyWithoutPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceAppCreateManyAppInput = {
    id?: number
    device_id: number
    status?: $Enums.DeviceAppStatus
  }

  export type DeviceAppUpdateWithoutAppInput = {
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
    device?: DeviceUpdateOneRequiredWithoutDeviceAppsNestedInput
  }

  export type DeviceAppUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceAppUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    status?: EnumDeviceAppStatusFieldUpdateOperationsInput | $Enums.DeviceAppStatus
  }

  export type DeviceGroupCreateManyGroupInput = {
    id?: number
    device_id: number
  }

  export type DeviceGroupUpdateWithoutGroupInput = {
    device?: DeviceUpdateOneRequiredWithoutDeviceGroupsNestedInput
  }

  export type DeviceGroupUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}